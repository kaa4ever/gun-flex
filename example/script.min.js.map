{"version":3,"sources":["webpack:///webpack/bootstrap 049aca754cd4bc47e384","webpack:///./example/script.js","webpack:///./~/gun/gun.js","webpack:///(webpack)/buildin/module.js"],"names":["localStorage","clear","gun","todo1","get","set","name","todo2","person1","put","person2","path","map","todo","id","console","log","asignee"],"mappings":"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E;AACrG,OAAM;AACN,aAAY,yBAAyB;AACrC,oBAAmB;AACnB,6BAA4B;AAC5B,OAAM,EAAE;AACR,MAAK;AACL;AACA,KAAI;AACJ,mBAAkB;AAClB;AACA;;AAEA;AACA,YAAW;AACX;AACA;AACA;AACA,MAAK;AACL,+BAA8B;AAC9B;AACA;AACA,wCAAuC;AACvC,sDAAqD;AACrD,6BAA4B;AAC5B,yBAAwB;AACxB,6CAA4C;AAC5C;AACA,MAAK,cAAc;AACnB,cAAa;AACb,MAAK;AACL,KAAI,GAAG;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA,KAAI;AACJ;AACA;AACA,gBAAe,YAAY,cAAc;AACzC,gCAA+B;AAC/B;AACA;AACA,4DAA2D,kBAAkB;AAC7E,4DAA2D,kBAAkB;AAC7E;AACA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA,4CAA2C,4BAA4B;AACvE,OAAM;AACN;AACA,KAAI,GAAG,qBAAqB,QAAQ,KAAK,mBAAmB,GAAG,EAAE;AACjE,gBAAe,YAAY,WAAW;AACtC;AACA;AACA,qBAAoB;AACpB;AACA;;AAEA,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,aAAY;AACZ,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,MAAK,cAAc;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAgC;;AAEhC,iCAAgC,iEAAiE,OAAO;;AAExG;AACA;AACA;AACA;AACA;;AAEA,GAAE;;AAEF,GAAE,eAAe;;AAEjB;;AAEA;AACA;AACA,mFAAkF,SAAS,cAAc;AACzG,2CAA0C,yCAAyC;AACnF;AACA,kCAAiC;AACjC;AACA,yBAAwB,QAAQ,WAAW;AAC3C,yBAAwB,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A,4BAA2B;AAC3B,2BAA0B,YAAY;AACtC;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,4BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA,sGAAqG,yBAAyB,GAAG;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,wBAAwB;AAC1D;AACA,sBAAqB,wBAAwB,EAAE;AAC/C;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,SAAS;AAC3B,uDAAsD;AACtD,KAAI;AACJ;AACA,0BAAyB;AACzB,kDAAiD;AACjD;AACA;AACA,KAAI;AACJ;AACA;AACA,oDAAmD,qFAAqF;AACxI;AACA;AACA,iBAAgB,wCAAwC,mEAAmE,8CAA8C;AACzK,wBAAuB;AACvB;AACA;AACA;AACA,wDAAuD,SAAS;AAChE,yBAAwB;AACxB;AACA;AACA,kBAAiB,UAAU;AAC3B,0BAAyB;AACzB;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD,MAAK;AACL,4CAA2C;AAC3C,iBAAgB;AAChB;AACA,mBAAkB,oDAAoD;AACtE,oCAAmC;AACnC;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,mCAAkC,wDAAwD;AAC1F;AACA;AACA,yBAAwB;AACxB,uBAAsB;AACtB;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,sBAAsB,6DAA6D,QAAQ;AAChH;AACA;AACA,4BAA2B;AAC3B,kBAAiB,SAAS;AAC1B,iBAAgB;AAChB,eAAc,sBAAsB,+DAA+D;AACnG;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB,gBAAe;AACf;AACA;AACA,6CAA4C;AAC5C,6BAA4B,0CAA0C;AACtE;AACA;AACA;AACA,sBAAqB;AACrB;AACA,4CAA2C,gBAAgB,WAAW;AACtE;AACA;AACA,KAAI,GAAG,UAAU;AACjB;AACA;;AAEA,GAAE;;AAEF,GAAE,eAAe;AACjB;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA,KAAI,SAAS,KAAK,oBAAoB,UAAU,WAAW;AAC3D,cAAa,mBAAmB,6DAA6D;AAC7F,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA,6EAA4E;AAC5E,wBAAuB;AACvB;AACA;AACA,gBAAe,kBAAkB,0BAA0B,UAAU;AACrE;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ,YAAW;AACX;AACA;AACA;AACA,kBAAiB;AACjB,KAAI,iBAAiB,sDAAsD;AAC3E;AACA;AACA;AACA,4BAA2B;AAC3B,KAAI;AACJ;AACA,mCAAkC;AAClC,sCAAqC;AACrC,yCAAwC;AACxC;AACA;AACA;AACA,0BAAyB;AACzB;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF,wBAAuB;AACvB,oCAAmC;AACnC,sDAAqD;AACrD,oCAAmC,eAAe;AAClD,kCAAiC,iBAAiB,aAAa;AAC/D;AACA,oBAAmB,0DAA0D;AAC7E,8BAA6B;AAC7B;AACA,iCAAgC;AAChC,8BAA6B;AAC7B,EAAC;;;AAGD,EAAC;;AAED,oCAAmC,QAAQ;AAC3C,kBAAiB;AACjB,mBAAkB,0FAA0F;;AAE5G,GAAE;AACF;AACA,kCAAiC,KAAK,wCAAwC,SAAS,YAAY;AACnG,6BAA4B,yBAAyB,OAAO,oDAAoD,SAAS,MAAM,IAAI;AACnI,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,oDAAmD,qBAAqB,0BAA0B;AAClG;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA,wEAAuE;AACvE;AACA;AACA,aAAY;AACZ;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,cAAa;AACb,8BAA6B;AAC7B,qCAAoC,2BAA2B;AAC/D,gBAAe,EAAE;AACjB,MAAK;AACL,KAAI;AACJ;AACA;AACA,4BAA2B,mDAAmD,GAAG,uBAAuB,GAAG,IAAI;AAC/G,MAAK;AACL,oEAAmE;AACnE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,wEAAuE,QAAQ,KAAK,SAAS,IAAI;AACjG,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iBAAgB,4BAA4B;AAC5C;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,wBAAuB,eAAe,UAAU;AAChD,wBAAuB;AACvB,mBAAkB,gCAAgC,uDAAuD;AACzG,gCAA+B;AAC/B,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE,uCAAsC;AACtC,gCAA+B;AAC/B;AACA,wBAAuB,SAAS;AAChC,6BAA4B;AAC5B,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,iBAAgB,UAAU;AAC1B,QAAO,mCAAmC;AAC1C;AACA;AACA,iBAAgB,UAAU,qEAAqE;AAC/F,kBAAiB,YAAY,+BAA+B,gBAAgB;AAC5E;AACA,4BAA2B;AAC3B,KAAI,GAAG;AACP;AACA,aAAY,YAAY,+BAA+B,6BAA6B;AACpF,yBAAwB;AACxB,iDAAgD,uCAAuC;AACvF;AACA,cAAa,YAAY,+BAA+B,uBAAuB;AAC/E,UAAS,+BAA+B,wBAAwB;AAChE,MAAK,GAAG,uBAAuB;AAC/B,KAAI,OAAO,KAAK,+BAA+B,iCAAiC;AAChF;AACA,4CAA2C;AAC3C;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF,EAAC,wBAAwB;;;AAGzB,EAAC;AACD;AACA,mCAAkC;AAClC,0BAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA,iCAAgC;AAChC;AACA;AACA,eAAc,qCAAqC;AACnD;AACA;AACA,cAAa,eAAe;AAC5B;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,eAAe;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB;AACpB,kBAAiB;AACjB,iBAAgB;AAChB;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA,gDAA+C;AAC/C;AACA;;AAEA,qBAAoB;;AAEpB;AACA;;AAEA,QAAO;AACP,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW;AACX,4CAA2C;AAC3C,yBAAwB;AACxB,0CAAyC;AACzC;AACA,aAAY;AACZ;AACA,sCAAqC;AACrC;AACA,4BAA2B,EAAE;AAC7B,MAAK;AACL;AACA,sCAAqC,oCAAoC;AACzE;AACA,uBAAsB;AACtB;AACA,SAAQ;AACR,MAAK,SAAS;AACd,cAAa;AACb;AACA,+BAA8B,sDAAsD;AACpF,kBAAiB,uCAAuC,8BAA8B,GAAG;AACzF;AACA,6BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,SAAQ;AACR,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uEAAsE;AACtE,0CAAyC,gEAAgE;AACzG;AACA,cAAa,0BAA0B;AACvC,uCAAsC,mBAAmB;AACzD;AACA;AACA,iEAAgE;AAChE;AACA;AACA,2BAA0B,oCAAoC,+BAA+B,GAAG;AAChG;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA,oCAAmC,0BAA0B;AAC7D;AACA,uBAAsB,wBAAwB,mCAAmC;AACjF,oBAAmB;AACnB,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF,oCAAmC;AACnC,sDAAqD;AACrD,EAAC,wBAAwB;;;;;;;;ACjhDzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"example/script.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 049aca754cd4bc47e384","import Gun from 'gun/gun';\n\nlocalStorage.clear();\n\nconst gun = new Gun();\n\n\n\nconst todo1 = gun.get('todos').set({ name: \"Clean house\" });\nconst todo2 = gun.get('todos').set({ name: \"Vacuum clean\" });\n\nconst person1 = gun.get('persons').put({ name: 'Kristian Kaa'});\nconst person2 = gun.get('persons').put({ name: 'Lisbeth Knudsen'});\n\ntodo1.path('assignees').set(person1);\ntodo1.path('assignees').set(person2);\n\ngun.get('todos').map((todo, id) => {\n  console.log('TODO', id, todo);\n});\n\ntodo1.path('assignees').map(asignee => {\n  console.log('ASSIGNEE', asignee);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./example/script.js",";(function(){\n\n\tfunction Gun(o){\n\t\tvar gun = this;\n\t\tif(!Gun.is(gun)){ return new Gun(o) }\n\t\tif(Gun.is(o)){ return gun }\n\t\treturn gun.opt(o);\n\t}\n\n\t;(function(Util){ // Generic javascript utilities.\n\t\t;(function(Type){\n\t\t\tType.fns = {is: function(fn){ return (fn instanceof Function)? true : false }};\n\t\t\tType.bi = {is: function(b){ return (b instanceof Boolean || typeof b == 'boolean')? true : false }}\n\t\t\tType.num = {is: function(n){ return !Type.list.is(n) && (Infinity === n || n - parseFloat(n) + 1 >= 0) }}\n\t\t\tType.text = {is: function(t){ return typeof t == 'string'? true : false }}\n\t\t\tType.text.ify = function(t){\n\t\t\t\tif(Type.text.is(t)){ return t }\n\t\t\t\tif(typeof JSON !== \"undefined\"){ return JSON.stringify(t) }\n\t\t\t\treturn (t && t.toString)? t.toString() : t;\n\t\t\t}\n\t\t\tType.text.random = function(l, c){\n\t\t\t\tvar s = '';\n\t\t\t\tl = l || 24; // you are not going to make a 0 length random number, so no need to check type\n\t\t\t\tc = c || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz';\n\t\t\t\twhile(l > 0){ s += c.charAt(Math.floor(Math.random() * c.length)); l-- }\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tType.text.match = function(t, o){ var r = false;\n\t\t\t\tt = t || '';\n\t\t\t\to = Gun.text.is(o)? {'=': o} : o || {}; // {'~', '=', '*', '<', '>', '+', '-', '?', '!'} // ignore uppercase, exactly equal, anything after, lexically larger, lexically lesser, added in, subtacted from, questionable fuzzy match, and ends with.\n\t\t\t\tif(Type.obj.has(o,'~')){ t = t.toLowerCase() }\n\t\t\t\tif(Type.obj.has(o,'=')){ return t === o['='] }\n\t\t\t\tif(Type.obj.has(o,'*')){ if(t.slice(0, o['*'].length) === o['*']){ r = true; t = t.slice(o['*'].length) } else { return false }}\n\t\t\t\tif(Type.obj.has(o,'!')){ if(t.slice(-o['!'].length) === o['!']){ r = true } else { return false }}\n\t\t\t\tif(Type.obj.has(o,'+')){\n\t\t\t\t\tif(Type.list.map(Type.list.is(o['+'])? o['+'] : [o['+']], function(m){\n\t\t\t\t\t\tif(t.indexOf(m) >= 0){ r = true } else { return true }\n\t\t\t\t\t})){ return false }\n\t\t\t\t}\n\t\t\t\tif(Type.obj.has(o,'-')){\n\t\t\t\t\tif(Type.list.map(Type.list.is(o['-'])? o['-'] : [o['-']], function(m){\n\t\t\t\t\t\tif(t.indexOf(m) < 0){ r = true } else { return true }\n\t\t\t\t\t})){ return false }\n\t\t\t\t}\n\t\t\t\tif(Type.obj.has(o,'>')){ if(t > o['>']){ r = true } else { return false }}\n\t\t\t\tif(Type.obj.has(o,'<')){ if(t < o['<']){ r = true } else { return false }}\n\t\t\t\tfunction fuzzy(t,f){ var n = -1, i = 0, c; for(;c = f[i++];){ if(!~(n = t.indexOf(c, n+1))){ return false }} return true } // via http://stackoverflow.com/questions/9206013/javascript-fuzzy-search\n\t\t\t\tif(Type.obj.has(o,'?')){ if(fuzzy(t, o['?'])){ r = true } else { return false }} // change name!\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tType.list = {is: function(l){ return (l instanceof Array)? true : false }}\n\t\t\tType.list.slit = Array.prototype.slice;\n\t\t\tType.list.sort = function(k){ // creates a new sort function based off some field\n\t\t\t\treturn function(A,B){\n\t\t\t\t\tif(!A || !B){ return 0 } A = A[k]; B = B[k];\n\t\t\t\t\tif(A < B){ return -1 }else if(A > B){ return 1 }\n\t\t\t\t\telse { return 0 }\n\t\t\t\t}\n\t\t\t}\n\t\t\tType.list.map = function(l, c, _){ return Type.obj.map(l, c, _) }\n\t\t\tType.list.index = 1; // change this to 0 if you want non-logical, non-mathematical, non-matrix, non-convenient array notation\n\t\t\tType.obj = {is: function(o) { return !o || !o.constructor? false : o.constructor === Object? true : !o.constructor.call || o.constructor.toString().match(/\\[native\\ code\\]/)? false : true }}\n\t\t\tType.obj.put = function(o, f, v){ return (o||{})[f] = v, o }\n\t\t\tType.obj.del = function(o, k){\n\t\t\t\tif(!o){ return }\n\t\t\t\to[k] = null;\n\t\t\t\tdelete o[k];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tType.obj.ify = function(o){\n\t\t\t\tif(Type.obj.is(o)){ return o }\n\t\t\t\ttry{o = JSON.parse(o);\n\t\t\t\t}catch(e){o={}};\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\tType.obj.copy = function(o){ // because http://web.archive.org/web/20140328224025/http://jsperf.com/cloning-an-object/2\n\t\t\t\treturn !o? o : JSON.parse(JSON.stringify(o)); // is shockingly faster than anything else, and our data has to be a subset of JSON anyways!\n\t\t\t}\n\t\t\tType.obj.as = function(b, f, d){ return b[f] = b[f] || (arguments.length >= 3? d : {}) }\n\t\t\tType.obj.has = function(o, t){ return o && Object.prototype.hasOwnProperty.call(o, t) }\n\t\t\tType.obj.empty = function(o, n){\n\t\t\t\tif(!o){ return true }\n\t\t\t\treturn Type.obj.map(o,function(v,i){\n\t\t\t\t\tif(n && (i === n || (Type.obj.is(n) && Type.obj.has(n, i)))){ return }\n\t\t\t\t\tif(i){ return true }\n\t\t\t\t})? false : true;\n\t\t\t}\n\t\t\tType.obj.map = function(l, c, _){\n\t\t\t\tvar u, i = 0, ii = 0, x, r, rr, ll, lle, f = Type.fns.is(c),\n\t\t\t\tt = function(k,v){\n\t\t\t\t\tif(2 === arguments.length){\n\t\t\t\t\t\trr = rr || {};\n\t\t\t\t\t\trr[k] = v;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} rr = rr || [];\n\t\t\t\t\trr.push(k);\n\t\t\t\t};\n\t\t\t\tif(Object.keys && Type.obj.is(l)){\n\t\t\t\t\tll = Object.keys(l); lle = true;\n\t\t\t\t}\n\t\t\t\tif(Type.list.is(l) || ll){\n\t\t\t\t\tx = (ll || l).length;\n\t\t\t\t\tfor(;i < x; i++){\n\t\t\t\t\t\tii = (i + Type.list.index);\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tr = lle? c.call(_ || this, l[ll[i]], ll[i], t) : c.call(_ || this, l[i], ii, t);\n\t\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//if(Type.test.is(c,l[i])){ return ii } // should implement deep equality testing!\n\t\t\t\t\t\t\tif(c === l[lle? ll[i] : i]){ return ll? ll[i] : ii } // use this for now\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor(i in l){\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tif(Type.obj.has(l,i)){\n\t\t\t\t\t\t\t\tr = _? c.call(_, l[i], i, t) : c(l[i], i, t);\n\t\t\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//if(a.test.is(c,l[i])){ return i } // should implement deep equality testing!\n\t\t\t\t\t\t\tif(c === l[i]){ return i } // use this for now\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn f? rr : Type.list.index? 0 : -1;\n\t\t\t}\n\t\t\tType.time = {};\n\t\t\tType.time.is = function(t){ return t? t instanceof Date : (+new Date().getTime()) }\n\t\t\tType.time.now = (function(){\n\t\t\t    var time = Type.time.is, last = -Infinity, n = 0, d = 1000;\n\t\t\t    return function(){\n\t\t\t        var t = time();\n\t\t\t        if(last < t){\n\t\t\t            n = 0;\n\t\t\t            return last = t;\n\t\t\t        }\n\t\t\t        return last = t + ((n += 1) / d);\n\t\t\t    }\n\t\t\t}());\n\t\t}(Util));\n\t\t;(function(exports){ // On event emitter generic javascript utility.\n\t\t\tfunction On(){};\n\t\t\tOn.create = function(){\n\t\t\t\tvar on = function(e){\n\t\t\t\t\ton.event.e = e;\n\t\t\t\t\ton.event.s[e] = on.event.s[e] || [];\n\t\t\t\t\treturn on;\n\t\t\t\t};\n\t\t\t\ton.emit = function(a){\n\t\t\t\t\tvar e = on.event.e, s = on.event.s[e], args = arguments, l = args.length;\n\t\t\t\t\texports.list.map(s, function(hear, i){\n\t\t\t\t\t\tif(!hear.fn){ s.splice(i-1, 0); return; }\n\t\t\t\t\t\tif(1 === l){ hear.fn(a); return; }\n\t\t\t\t\t\thear.fn.apply(hear, args);\n\t\t\t\t\t});\n\t\t\t\t\tif(!s.length){ delete on.event.s[e] }\n\t\t\t\t}\n\t\t\t\ton.event = function(fn, i){\n\t\t\t\t\tvar s = on.event.s[on.event.e]; if(!s){ return }\n\t\t\t\t\tvar e = {fn: fn, i: i || 0, off: function(){ return !(e.fn = false) }};\n\t\t\t\t\treturn s.push(e), i? s.sort(sort) : i, e;\n\t\t\t\t}\n\t\t\t\ton.event.s = {};\n\t\t\t\treturn on;\n\t\t\t}\n\t\t\tvar sort = exports.list.sort('i');\n\t\t\texports.on = On.create();\n\t\t\texports.on.create = On.create;\n\t\t}(Util));\n\t\t;(function(exports){ // Generic javascript scheduler utility.\n\t\t\tvar schedule = function(state, cb){ // maybe use lru-cache?\n\t\t\t\tschedule.waiting.push({when: state, event: cb || function(){}});\n\t\t\t\tif(schedule.soonest < state){ return }\n\t\t\t\tschedule.set(state);\n\t\t\t}\n\t\t\tschedule.waiting = [];\n\t\t\tschedule.soonest = Infinity;\n\t\t\tschedule.sort = exports.list.sort('when');\n\t\t\tschedule.set = function(future){\n\t\t\t\tif(Infinity <= (schedule.soonest = future)){ return }\n\t\t\t\tvar now = exports.time.now(); // WAS time.is() TODO: Hmmm, this would make it hard for every gun instance to have their own version of time.\n\t\t\t\tfuture = (future <= now)? 0 : (future - now);\n\t\t\t\tclearTimeout(schedule.id);\n\t\t\t\tschedule.id = setTimeout(schedule.check, future);\n\t\t\t}\n\t\t\tschedule.check = function(){\n\t\t\t\tvar now = exports.time.now(), soonest = Infinity; // WAS time.is() TODO: Same as above about time. Hmmm.\n\t\t\t\tschedule.waiting.sort(schedule.sort);\n\t\t\t\tschedule.waiting = exports.list.map(schedule.waiting, function(wait, i, map){\n\t\t\t\t\tif(!wait){ return }\n\t\t\t\t\tif(wait.when <= now){\n\t\t\t\t\t\tif(exports.fns.is(wait.event)){\n\t\t\t\t\t\t\tsetTimeout(function(){ wait.event() },0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsoonest = (soonest < wait.when)? soonest : wait.when;\n\t\t\t\t\t\tmap(wait);\n\t\t\t\t\t}\n\t\t\t\t}) || [];\n\t\t\t\tschedule.set(soonest);\n\t\t\t}\n\t\t\texports.schedule = schedule;\n\t\t}(Util));\n\t}(Gun));\n\n\t;(function(Gun){ // Gun specific utilities.\n\n\t\tGun.version = 0.3;\n\n\t\tGun._ = { // some reserved key words, these are not the only ones.\n\t\t\tmeta: '_' // all metadata of the node is stored in the meta property on the node.\n\t\t\t,soul: '#' // a soul is a UUID of a node but it always points to the \"latest\" data known.\n\t\t\t,field: '.' // a field is a property on a node which points to a value.\n\t\t\t,state: '>' // other than the soul, we store HAM metadata.\n\t\t\t,'#':'soul'\n\t\t\t,'.':'field'\n\t\t\t,'=':'value'\n\t\t\t,'>':'state'\n\t\t}\n\n\t\tGun.is = function(gun){ return (gun instanceof Gun)? true : false } // check to see if it is a GUN instance.\n\n\t\tGun.is.val = function(v){ // Valid values are a subset of JSON: null, binary, number (!Infinity), text, or a soul relation. Arrays need special algorithms to handle concurrency, so they are not supported directly. Use an extension that supports them if needed but research their problems first.\n\t\t\tif(v === null){ return true } // \"deletes\", nulling out fields.\n\t\t\tif(v === Infinity){ return false } // we want this to be, but JSON does not support it, sad face.\n\t\t\tif(Gun.bi.is(v) // by \"binary\" we mean boolean.\n\t\t\t|| Gun.num.is(v)\n\t\t\t|| Gun.text.is(v)){ // by \"text\" we mean strings.\n\t\t\t\treturn true; // simple values are valid.\n\t\t\t}\n\t\t\treturn Gun.is.rel(v) || false; // is the value a soul relation? Then it is valid and return it. If not, everything else remaining is an invalid data type. Custom extensions can be built on top of these primitives to support other types.\n\t\t}\n\n\t\tGun.is.rel = function(v){ // this defines whether an object is a soul relation or not, they look like this: {'#': 'UUID'}\n\t\t\tif(Gun.obj.is(v)){ // must be an object.\n\t\t\t\tvar id;\n\t\t\t\tGun.obj.map(v, function(s, f){ // map over the object...\n\t\t\t\t\tif(id){ return id = false } // if ID is already defined AND we're still looping through the object, it is considered invalid.\n\t\t\t\t\tif(f == Gun._.soul && Gun.text.is(s)){ // the field should be '#' and have a text value.\n\t\t\t\t\t\tid = s; // we found the soul!\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn id = false; // if there exists anything else on the object that isn't the soul, then it is considered invalid.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(id){ // a valid id was found.\n\t\t\t\t\treturn id; // yay! Return it.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; // the value was not a valid soul relation.\n\t\t}\n\n\t\tGun.is.rel.ify = function(s){ var r = {}; return Gun.obj.put(r, Gun._.soul, s), r } // convert a soul into a relation and return it.\n\n\t\tGun.is.lex = function(l){ var r = true;\n\t\t\tif(!Gun.obj.is(l)){ return false }\n\t\t\tGun.obj.map(l, function(v,f){\n\t\t\t\tif(!Gun.obj.has(Gun._,f) || !(Gun.text.is(v) || Gun.obj.is(v))){ return r = false }\n\t\t\t}); // TODO: What if the lex cursor has a document on the match, that shouldn't be allowed!\n\t\t\treturn r;\n\t\t}\n\n\t\tGun.is.node = function(n, cb, t){ var s; // checks to see if an object is a valid node.\n\t\t\tif(!Gun.obj.is(n)){ return false } // must be an object.\n\t\t\tif(s = Gun.is.node.soul(n)){ // must have a soul on it.\n\t\t\t\treturn !Gun.obj.map(n, function(v, f){ // we invert this because the way we check for this is via a negation.\n\t\t\t\t\tif(f == Gun._.meta){ return } // skip over the metadata.\n\t\t\t\t\tif(!Gun.is.val(v)){ return true } // it is true that this is an invalid node.\n\t\t\t\t\tif(cb){ cb.call(t, v, f, n) } // optionally callback each field/value.\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false; // nope! This was not a valid node.\n\t\t}\n\n\t\tGun.is.node.ify = function(n, s, o){ // convert a shallow object into a node.\n\t\t\to = Gun.bi.is(o)? {force: o} : o || {}; // detect options.\n\t\t\tn = Gun.is.node.soul.ify(n, s, o.force); // put a soul on it.\n\t\t\tGun.obj.map(n, function(v, f){ // iterate over each field/value.\n\t\t\t\tif(Gun._.meta === f){ return } // ignore meta.\n\t\t\t\tGun.is.node.state.ify([n], f, v, o.state = o.state || Gun.time.now()); // and set the state for this field and value on this node.\n\t\t\t});\n\t\t\treturn n; // This will only be a valid node if the object wasn't already deep!\n\t\t}\n\n\t\tGun.is.node.soul = function(n, s){ return (n && n._ && n._[s || Gun._.soul]) || false } // convenience function to check to see if there is a soul on a node and return it.\n\n\t\tGun.is.node.soul.ify = function(n, s, o){ // put a soul on an object.\n\t\t\tn = n || {}; // make sure it exists.\n\t\t\tn._ = n._ || {}; // make sure meta exists.\n\t\t\tn._[Gun._.soul] = o? s : n._[Gun._.soul] || s || Gun.text.random(); // if it already has a soul then use that instead - unless you force the soul you want with an option.\n\t\t\treturn n;\n\t\t}\n\n\t\tGun.is.node.state = function(n, f){ return (f && n && n._ && n._[Gun._.state] && Gun.num.is(n._[Gun._.state][f]))? n._[Gun._.state][f] : false } // convenience function to get the state on a field on a node and return it.\n\n\t\tGun.is.node.state.ify = function(l, f, v, state){ // put a field's state and value on some nodes.\n\t\t\tl = Gun.list.is(l)? l : [l]; // handle a list of nodes or just one node.\n\t\t\tvar l = l.reverse(), d = l[0]; // we might want to inherit the state from the last node in the list.\n\t\t\tGun.list.map(l, function(n, i){ // iterate over each node.\n\t\t\t\tn = n || {}; // make sure it exists.\n\t\t\t\tif(Gun.is.val(v)){ n[f] = v } // if we have a value, then put it.\n\t\t\t\tn._ = n._ || {}; // make sure meta exists.\n\t\t\t\tn = n._[Gun._.state] = n._[Gun._.state] || {}; // make sure HAM state exists.\n\t\t\t\tif(i = d._[Gun._.state][f]){ n[f] = i } // inherit the state!\n\t\t\t\tif(Gun.num.is(state)){ n[f] = state } // or manually set the state.\n\t\t\t});\n\t\t}\n\n\t\tGun.is.graph = function(g, cb, fn, t){ // checks to see if an object is a valid graph.\n\t\t\tvar exist = false;\n\t\t\tif(!Gun.obj.is(g)){ return false } // must be an object.\n\t\t\treturn !Gun.obj.map(g, function(n, s){ // we invert this because the way we check for this is via a negation.\n\t\t\t\tif(!n || s !== Gun.is.node.soul(n) || !Gun.is.node(n, fn)){ return true } // it is true that this is an invalid graph.\n\t\t\t\t(cb || function(){}).call(t, n, s, function(fn){ // optional callback for each node.\n\t\t\t\t\tif(fn){ Gun.is.node(n, fn, t) } // where we then have an optional callback for each field/value.\n\t\t\t\t});\n\t\t\t\texist = true;\n\t\t\t}) && exist; // makes sure it wasn't an empty object.\n\t\t}\n\n\t\tGun.is.graph.ify = function(n){ var s; // wrap a node into a graph.\n\t\t\tif(s = Gun.is.node.soul(n)){ // grab the soul from the node, if it is a node.\n\t\t\t\treturn Gun.obj.put({}, s, n); // then create and return a graph which has a node on the matching soul property.\n\t\t\t}\n\t\t}\n\n\n\t\tGun.HAM = function(machineState, incomingState, currentState, incomingValue, currentValue){ // TODO: Lester's comments on roll backs could be vulnerable to divergence, investigate!\n\t\t\tif(machineState < incomingState){\n\t\t\t\t// the incoming value is outside the boundary of the machine's state, it must be reprocessed in another state.\n\t\t\t\treturn {defer: true};\n\t\t\t}\n\t\t\tif(incomingState < currentState){\n\t\t\t\t// the incoming value is within the boundary of the machine's state, but not within the range.\n\t\t\t\treturn {historical: true};\n\t\t\t}\n\t\t\tif(currentState < incomingState){\n\t\t\t\t// the incoming value is within both the boundary and the range of the machine's state.\n\t\t\t\treturn {converge: true, incoming: true};\n\t\t\t}\n\t\t\tif(incomingState === currentState){\n\t\t\t\tif(incomingValue === currentValue){ // Note: while these are practically the same, the deltas could be technically different\n\t\t\t\t\treturn {state: true};\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\tThe following is a naive implementation, but will always work.\n\t\t\t\t\tNever change it unless you have specific needs that absolutely require it.\n\t\t\t\t\tIf changed, your data will diverge unless you guarantee every peer's algorithm has also been changed to be the same.\n\t\t\t\t\tAs a result, it is highly discouraged to modify despite the fact that it is naive,\n\t\t\t\t\tbecause convergence (data integrity) is generally more important.\n\t\t\t\t\tAny difference in this algorithm must be given a new and different name.\n\t\t\t\t*/\n\t\t\t\tif(String(incomingValue) < String(currentValue)){ // String only works on primitive values!\n\t\t\t\t\treturn {converge: true, current: true};\n\t\t\t\t}\n\t\t\t\tif(String(currentValue) < String(incomingValue)){ // String only works on primitive values!\n\t\t\t\t\treturn {converge: true, incoming: true};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {err: \"you have not properly handled recursion through your data or filtered it as JSON\"};\n\t\t}\n\n\t\tGun.union = function(gun, prime, cb, opt){ // merge two graphs into the first.\n\t\t\tvar opt = opt || Gun.obj.is(cb)? cb : {};\n\t\t\tvar ctx = {graph: gun.__.graph, count: 0};\n\t\t\tctx.cb = function(){\n\t\t\t\tcb = Gun.fns.is(cb)? cb() && null : null;\n\t\t\t}\n\t\t\tif(!ctx.graph){ ctx.err = {err: Gun.log(\"No graph!\") } }\n\t\t\tif(!prime){ ctx.err = {err: Gun.log(\"No data to merge!\") } }\n\t\t\tif(ctx.soul = Gun.is.node.soul(prime)){ prime = Gun.is.graph.ify(prime) }\n\t\t\tif(!Gun.is.graph(prime, null, function(val, field, node){ var meta;\n\t\t\t\tif(!Gun.num.is(Gun.is.node.state(node, field))){\n\t\t\t\t\treturn ctx.err = {err: Gun.log(\"No state on '\" + field + \"'!\") }\n\t\t\t\t}\n\t\t\t}) || ctx.err){ return ctx.err = ctx.err || {err: Gun.log(\"Invalid graph!\", prime)}, ctx }\n\t\t\tfunction emit(at){\n\t\t\t\tGun.on('operating').emit(gun, at);\n\t\t\t}\n\t\t\t(function union(graph, prime){\n\t\t\t\tvar prime = Gun.obj.map(prime, function(n,s,t){t(n)}).sort(function(A,B){\n\t\t\t\t\tvar s = Gun.is.node.soul(A);\n\t\t\t\t\tif(graph[s]){ return 1 }\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t\tctx.count += 1;\n\t\t\t\tctx.err = Gun.list.map(prime, function(node, soul){\n\t\t\t\t\tsoul = Gun.is.node.soul(node);\n\t\t\t\t\tif(!soul){ return {err: Gun.log(\"Soul missing or mismatching!\")} }\n\t\t\t\t\tctx.count += 1;\n\t\t\t\t\tvar vertex = graph[soul];\n\t\t\t\t\tif(!vertex){ graph[soul] = vertex = Gun.is.node.ify({}, soul) }\n\t\t\t\t\tGun.union.HAM(vertex, node, function(vertex, field, val, state){\n\t\t\t\t\t\tGun.on('historical').emit(gun, {soul: soul, field: field, value: val, state: state, change: node});\n\t\t\t\t\t\tgun.__.on('historical').emit({soul: soul, field: field, change: node});\n\t\t\t\t\t}, function(vertex, field, val, state){\n\t\t\t\t\t\tif(!vertex){ return }\n\t\t\t\t\t\tvar change = Gun.is.node.soul.ify({}, soul);\n\t\t\t\t\t\tif(field){\n\t\t\t\t\t\t\tGun.is.node.state.ify([vertex, change, node], field, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temit({soul: soul, field: field, value: val, state: state, change: change});\n\t\t\t\t\t}, function(vertex, field, val, state){\n\t\t\t\t\t\tGun.on('deferred').emit(gun, {soul: soul, field: field, value: val, state: state, change: node});\n\t\t\t\t\t})(function(){\n\t\t\t\t\t\temit({soul: soul, change: node});\n\t\t\t\t\t\tif(opt.soul){ opt.soul(soul) }\n\t\t\t\t\t\tif(!(ctx.count -= 1)){ ctx.cb() }\n\t\t\t\t\t}); // TODO: BUG? Handle error!\n\t\t\t\t});\n\t\t\t\tctx.count -= 1;\n\t\t\t})(ctx.graph, prime);\n\t\t\tif(!ctx.count){ ctx.cb() }\n\t\t\treturn ctx;\n\t\t}\n\n\t\tGun.union.ify = function(gun, prime, cb, opt){\n\t\t\tif(gun){ gun = (gun.__ && gun.__.graph)? gun.__.graph : gun }\n\t\t\tif(Gun.text.is(prime)){\n\t\t\t\tif(gun && gun[prime]){\n\t\t\t\t\tprime = gun[prime];\n\t\t\t\t} else {\n\t\t\t\t\treturn Gun.is.node.ify({}, prime);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar vertex = Gun.is.node.soul.ify({}, Gun.is.node.soul(prime)), prime = Gun.is.graph.ify(prime) || prime;\n\t\t\tif(Gun.is.graph(prime, null, function(val, field){ var node;\n\t\t\t\tfunction merge(a, f, v){ Gun.is.node.state.ify(a, f, v) }\n\t\t\t\tif(Gun.is.rel(val)){ node = gun? gun[field] || prime[field] : prime[field] }\n\t\t\t\tGun.union.HAM(vertex, node, function(){}, function(vert, f, v){\n\t\t\t\t\tmerge([vertex, node], f, v);\n\t\t\t\t}, function(){})(function(err){\n\t\t\t\t\tif(err){ merge([vertex], field, val) }\n\t\t\t\t})\n\t\t\t})){ return vertex }\n\t\t}\n\n\t\tGun.union.HAM = function(vertex, delta, lower, now, upper){\n\t\t\tupper.max = -Infinity;\n\t\t\tnow.end = true;\n\t\t\tdelta = delta || {};\n\t\t\tvertex = vertex || {};\n\t\t\tGun.obj.map(delta._, function(v,f){\n\t\t\t\tif(Gun._.state === f || Gun._.soul === f){ return }\n\t\t\t\tvertex._[f] = v;\n\t\t\t});\n\t\t\tif(!Gun.is.node(delta, function update(incoming, field){\n\t\t\t\tnow.end = false;\n\t\t\t\tvar ctx = {incoming: {}, current: {}}, state;\n\t\t\t\tctx.drift = Gun.time.now(); // DANGEROUS!\n\t\t\t\tctx.incoming.value = Gun.is.rel(incoming) || incoming;\n\t\t\t\tctx.current.value = Gun.is.rel(vertex[field]) || vertex[field];\n\t\t\t\tctx.incoming.state = Gun.num.is(ctx.tmp = ((delta._||{})[Gun._.state]||{})[field])? ctx.tmp : -Infinity;\n\t\t\t\tctx.current.state = Gun.num.is(ctx.tmp = ((vertex._||{})[Gun._.state]||{})[field])? ctx.tmp : -Infinity;\n\t\t\t\tupper.max = ctx.incoming.state > upper.max? ctx.incoming.state : upper.max;\n\t\t\t\tstate = Gun.HAM(ctx.drift, ctx.incoming.state, ctx.current.state, ctx.incoming.value, ctx.current.value);\n\t\t\t\tif(state.err){\n\t\t\t\t\troot.console.log(\".!HYPOTHETICAL AMNESIA MACHINE ERR!.\", state.err); // this error should never happen.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(state.state || state.historical || state.current){\n\t\t\t\t\tlower.call(state, vertex, field, incoming, ctx.incoming.state);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(state.incoming){\n\t\t\t\t\tnow.call(state, vertex, field, incoming, ctx.incoming.state);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(state.defer){\n\t\t\t\t\tupper.wait = true;\n\t\t\t\t\tupper.call(state, vertex, field, incoming, ctx.incoming.state); // signals that there are still future modifications.\n\t\t\t\t\tGun.schedule(ctx.incoming.state, function(){\n\t\t\t\t\t\tupdate(incoming, field);\n\t\t\t\t\t\tif(ctx.incoming.state === upper.max){ (upper.last || function(){})() }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})){ return function(fn){ if(fn){ fn({err: 'Not a node!'}) } } }\n\t\t\tif(now.end){ now.call({}, vertex) } // TODO: Should HAM handle empty updates? YES.\n\t\t\treturn function(fn){\n\t\t\t\tupper.last = fn || function(){};\n\t\t\t\tif(!upper.wait){ upper.last() }\n\t\t\t}\n\t\t}\n\n\t\tGun.on.at = function(on){ // On event emitter customized for gun.\n\t\t\tvar proxy = function(e){ return proxy.e = e, proxy }\n\t\t\tproxy.emit = function(at){\n\t\t\t\tif(at.soul){\n\t\t\t\t\tat.hash = Gun.on.at.hash(at);\n\t\t\t\t\t//Gun.obj.as(proxy.mem, proxy.e)[at.soul] = at;\n\t\t\t\t\tGun.obj.as(proxy.mem, proxy.e)[at.hash] = at;\n\t\t\t\t}\n\t\t\t\tif(proxy.all.cb){ proxy.all.cb(at, proxy.e) }\n\t\t\t\ton(proxy.e).emit(at);\n\t\t\t\treturn {chain: function(c){\n\t\t\t\t\tif(!c || !c._ || !c._.at){ return }\n\t\t\t\t\treturn c._.at(proxy.e).emit(at)\n\t\t\t\t}};\n\t\t\t}\n\t\t\tproxy.only = function(cb){\n\t\t\t\tif(proxy.only.cb){ return }\n\t\t\t\treturn proxy.event(proxy.only.cb = cb);\n\t\t\t}\n\t\t\tproxy.all = function(cb){\n\t\t\t\tproxy.all.cb = cb;\n\t\t\t\tGun.obj.map(proxy.mem, function(mem, e){\n\t\t\t\t\tGun.obj.map(mem, function(at, i){\n\t\t\t\t\t\tcb(at, e);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tproxy.event = function(cb, i){\n\t\t\t\ti = on(proxy.e).event(cb, i);\n\t\t\t\treturn Gun.obj.map(proxy.mem[proxy.e], function(at){\n\t\t\t\t\ti.stat = {first: true};\n\t\t\t\t\tcb.call(i, at);\n\t\t\t\t}), i.stat = {}, i;\n\t\t\t}\n\t\t\tproxy.map = function(cb, i){\n\t\t\t\treturn proxy.event(cb, i);\n\t\t\t};\n\t\t\tproxy.mem = {};\n\t\t\treturn proxy;\n\t\t}\n\n\t\tGun.on.at.hash = function(at){ return (at.at && at.at.soul)? at.at.soul + (at.at.field || '') : at.soul + (at.field || '') }\n\n\t\tGun.on.at.copy = function(at){ return Gun.obj.del(at, 'hash'), Gun.obj.map(at, function(v,f,t){t(f,v)}) }\n\n\t\tGun.root = function(gun) {\n\t\t\tif (!Gun.is(gun)) return null;\n\t\t\tif (gun.back === gun) return gun;\n\t\t\treturn Gun.root(gun.back);\n\t\t};\n\n\t}(Gun));\n\n\t;(function(Gun){ // Gun prototype chain methods.\n\n\t\tGun.chain = Gun.prototype;\n\n\t\tGun.chain.opt = function(opt, stun){\n\t\t\topt = opt || {};\n\t\t\tvar gun = this, root = (gun.__ && gun.__.gun)? gun.__.gun : (gun._ = gun.__ = {gun: gun}).gun.chain(); // if root does not exist, then create a root chain.\n\t\t\troot.__.by = root.__.by || function(f){ return gun.__.by[f] = gun.__.by[f] || {} };\n\t\t\troot.__.graph = root.__.graph || {};\n\t\t\troot.__.opt = root.__.opt || {peers: {}};\n\t\t\troot.__.opt.wire = root.__.opt.wire || {};\n\t\t\tif(Gun.text.is(opt)){ opt = {peers: opt} }\n\t\t\tif(Gun.list.is(opt)){ opt = {peers: opt} }\n\t\t\tif(Gun.text.is(opt.peers)){ opt.peers = [opt.peers] }\n\t\t\tif(Gun.list.is(opt.peers)){ opt.peers = Gun.obj.map(opt.peers, function(n,f,m){ m(n,{}) }) }\n\t\t\tGun.obj.map(opt.peers, function(v, f){\n\t\t\t\troot.__.opt.peers[f] = v;\n\t\t\t});\n\t\t\tGun.obj.map(opt.wire, function(h, f){\n\t\t\t\tif(!Gun.fns.is(h)){ return }\n\t\t\t\troot.__.opt.wire[f] = h;\n\t\t\t});\n\t\t\tGun.obj.map(['key', 'on', 'path', 'map', 'not', 'init'], function(f){\n\t\t\t\tif(!opt[f]){ return }\n\t\t\t\troot.__.opt[f] = opt[f] || root.__.opt[f];\n\t\t\t});\n\t\t\tif(!stun){ Gun.on('opt').emit(root, opt) }\n\t\t\treturn gun;\n\t\t}\n\n\t\tGun.chain.chain = function(s){\n\t\t\tvar from = this, gun = !from.back? from : new this.constructor(from);//Gun(from);\n\t\t\tgun._ = gun._ || {};\n\t\t\tgun._.back = gun.back || from;\n\t\t\tgun.back = gun.back || from;\n\t\t\tgun.__ = gun.__ || from.__;\n\t\t\tgun._.on = gun._.on || Gun.on.create();\n\t\t\tgun._.at = gun._.at || Gun.on.at(gun._.on);\n\t\t\treturn gun;\n\t\t}\n\n\t\tGun.chain.put = function(val, cb, opt){\n\t\t\topt = opt || {};\n\t\t\tcb = cb || function(){}; cb.hash = {};\n\t\t\tvar gun = this, chain = gun.chain(), tmp = {val: val}, drift = Gun.time.now();\n\t\t\tfunction put(at){\n\t\t\t\tvar val = tmp.val;\n\t\t\t\tvar ctx = {obj: val}; // prep the value for serialization\n\t\t\t\tctx.soul = at.field? at.soul : (at.at && at.at.soul) || at.soul; // figure out where we are\n\t\t\t\tctx.field = at.field? at.field : (at.at && at.at.field) || at.field; // did we come from some where?\n\t\t\t\tif(Gun.is(val)){\n\t\t\t\t\tif(!ctx.field){ return cb.call(chain, {err: ctx.err = Gun.log('No field to link node to!')}), chain._.at('err').emit(ctx.err) }\n\t\t\t\t\treturn val.val(function(node){\n\t\t\t\t\t\tvar soul = Gun.is.node.soul(node);\n\t\t\t\t\t\tif(!soul){ return cb.call(chain, {err: ctx.err = Gun.log('Only a node can be linked! Not \"' + node + '\"!')}), chain._.at('err').emit(ctx.err) }\n\t\t\t\t\t\ttmp.val = Gun.is.rel.ify(soul);\n\t\t\t\t\t\tput(at);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif(cb.hash[at.hash = at.hash || Gun.on.at.hash(at)]){ return } // if we have already seen this hash...\n\t\t\t\tcb.hash[at.hash] = true; // else mark that we're processing the data (failure to write could still occur).\n\t\t\t\tctx.by = chain.__.by(ctx.soul);\n\t\t\t\tctx.not = at.not || (at.at && at.at.not);\n\t\t\t\tGun.obj.del(at, 'not'); Gun.obj.del(at.at || at, 'not'); // the data is no longer not known! // TODO: BUG! It could have been asynchronous by the time we now delete these properties. Don't other parts of the code assume their deletion is synchronous?\n\t\t\t\tif(ctx.field){ Gun.obj.as(ctx.obj = {}, ctx.field, val) } // if there is a field, then data is actually getting put on the parent.\n\t\t\t\telse if(!Gun.obj.is(val)){ return cb.call(chain, ctx.err = {err: Gun.log(\"No node exists to put \" + (typeof val) + ' \"' + val + '\" in!')}), chain._.at('err').emit(ctx.err) } // if the data is a primitive and there is no context for it yet, then we have an error.\n\t\t\t\t// TODO: BUG? gun.get(key).path(field).put() isn't doing it as pseudo.\n\t\t\t\tfunction soul(env, cb, map){ var eat;\n\t\t\t\t\tif(!env || !(eat = env.at) || !env.at.node){ return }\n\t\t\t\t\tif(!eat.node._){ eat.node._ = {} }\n\t\t\t\t\tif(!eat.node._[Gun._.state]){ eat.node._[Gun._.state] = {} }\n\t\t\t\t\tif(!Gun.is.node.soul(eat.node)){\n\t\t\t\t\t\tif(ctx.obj === eat.obj){\n\t\t\t\t\t\t\tGun.obj.as(env.graph, eat.soul = Gun.obj.as(eat.node._, Gun._.soul, Gun.is.node.soul(eat.obj) || ctx.soul), eat.node);\n\t\t\t\t\t\t\tcb(eat, eat.soul);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar path = function(err, node){\n\t\t\t\t\t\t\t\tif(path.opt && path.opt.on && path.opt.on.off){ path.opt.on.off() }\n\t\t\t\t\t\t\t\tif(path.opt.done){ return }\n\t\t\t\t\t\t\t\tpath.opt.done = true;\n\t\t\t\t\t\t\t\tif(err){ env.err = err }\n\t\t\t\t\t\t\t\teat.soul = Gun.is.node.soul(node) || Gun.is.node.soul(eat.obj) || Gun.is.node.soul(eat.node) || Gun.text.random();\n\t\t\t\t\t\t\t\tGun.obj.as(env.graph, Gun.obj.as(eat.node._, Gun._.soul, eat.soul), eat.node);\n\t\t\t\t\t\t\t\tcb(eat, eat.soul);\n\t\t\t\t\t\t\t}; path.opt = {put: true};\n\t\t\t\t\t\t\t(ctx.not)? path() : ((at.field || at.at)? gun._.back : gun).path(eat.path || [], path, path.opt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!eat.field){ return }\n\t\t\t\t\teat.node._[Gun._.state][eat.field] = drift;\n\t\t\t\t}\n\t\t\t\tfunction end(err, ify){\n\t\t\t\t\tctx.ify = ify;\n\t\t\t\t\tGun.on('put').emit(chain, at, ctx, opt, cb, val);\n\t\t\t\t\tif(err || ify.err){ return cb.call(chain, err || ify.err), chain._.at('err').emit(err || ify.err) } // check for serialization error, emit if so.\n\t\t\t\t\tif(err = Gun.union(chain, ify.graph, {end: false, soul: function(soul){\n\t\t\t\t\t\tif(chain.__.by(soul).end){ return }\n\t\t\t\t\t\tGun.union(chain, Gun.is.node.soul.ify({}, soul)); // fire off an end node if there hasn't already been one, to comply with the wire spec.\n\t\t\t\t\t}}).err){ return cb.call(chain, err), chain._.at('err').emit(err) } // now actually union the serialized data, emit error if any occur.\n\t\t\t\t\tif(Gun.fns.is(end.wire = chain.__.opt.wire.put)){\n\t\t\t\t\t\tvar wcb = function(err, ok, info){\n\t\t\t\t\t\t\tif(err){ return Gun.log(err.err || err), cb.call(chain, err), chain._.at('err').emit(err) }\n\t\t\t\t\t\t\treturn cb.call(chain, err, ok);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tend.wire(ify.graph, wcb, opt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(!Gun.log.count('no-wire-put')){ Gun.log(\"Warning! You have no persistence layer to save to!\") }\n\t\t\t\t\t\tcb.call(chain, null); // This is in memory success, hardly \"success\" at all.\n\t\t\t\t\t}\n\t\t\t\t\tif(ctx.field){\n\t\t\t\t\t\treturn gun._.back.path(ctx.field, null, {chain: opt.chain || chain});\n\t\t\t\t\t}\n\t\t\t\t\tif(ctx.not){\n\t\t\t\t\t\treturn gun.__.gun.get(ctx.soul, null, {chain: opt.chain || chain});\n\t\t\t\t\t}\n\t\t\t\t\tchain.get(ctx.soul, null, {chain: opt.chain || chain, at: gun._.at })\n\t\t\t\t}\n\t\t\t\tGun.ify(ctx.obj, soul, {pure: true})(end); // serialize the data!\n\t\t\t}\n\t\t\tif(gun === gun.back){ // if we are the root chain...\n\t\t\t\tput({soul: Gun.is.node.soul(val) || Gun.text.random(), not: true}); // then cause the new chain to save data!\n\t\t\t} else { // else if we are on an existing chain then...\n\t\t\t\tgun._.at('soul').map(put); // put data on every soul that flows through this chain.\n\t\t\t\tvar back = function(gun){\n\t\t\t\t\tif(back.get || gun._.back === gun || gun._.not){ return } // TODO: CLEAN UP! Would be ideal to accomplish this in a more ideal way.\n\t\t\t\t\tif(gun._.get){ back.get = true }\n\t\t\t\t\tgun._.at('null').event(function(at){ this.off();\n\t\t\t\t\t\tif(opt.init || gun.__.opt.init){ return Gun.log(\"Warning! You have no context to `.put`\", val, \"!\") }\n\t\t\t\t\t\tgun.init();\n\t\t\t\t\t}, -999);\n\t\t\t\t\treturn back(gun._.back);\n\t\t\t\t};\n\t\t\t\tif(!opt.init && !gun.__.opt.init){ back(gun) }\n\t\t\t}\n\t\t\tchain.back = gun.back;\n\t\t\treturn chain;\n\t\t}\n\n\t\tGun.chain.get = (function(){\n\t\t\tGun.on('operating').event(function(gun, at){\n\t\t\t\tif(!gun.__.by(at.soul).node){ gun.__.by(at.soul).node = gun.__.graph[at.soul]  }\n\t\t\t\tif(at.field){ return } // TODO: It would be ideal to reuse HAM's field emit.\n\t\t\t\tgun.__.on(at.soul).emit(at);\n\t\t\t});\n\t\t\tGun.on('get').event(function(gun, at, ctx, opt, cb){\n\t\t\t\tif(ctx.halt){ return } // TODO: CLEAN UP with event emitter option?\n\t\t\t\tat.change = at.change || gun.__.by(at.soul).node;\n\t\t\t\tif(opt.raw){ return cb.call(opt.on, at) }\n\t\t\t\tif(!ctx.cb.no){ cb.call(ctx.by.chain, null, Gun.obj.copy(ctx.node || gun.__.by(at.soul).node)) }\n\t\t\t\tgun._.at('soul').emit(at).chain(opt.chain);\n\t\t\t},0);\n\t\t\tGun.on('get').event(function(gun, at, ctx){\n\t\t\t\tif(ctx.halt){ ctx.halt = false; return } // TODO: CLEAN UP with event emitter option?\n\t\t\t}, Infinity);\n\t\t\treturn function(lex, cb, opt){ // get opens up a reference to a node and loads it.\n\t\t\t\tvar gun = this, ctx = {\n\t\t\t\t\topt: opt || {},\n\t\t\t\t\tcb: cb || function(){},\n\t\t\t\t\tlex: (Gun.text.is(lex) || Gun.num.is(lex))? Gun.is.rel.ify(lex) : lex,\n\t\t\t\t};\n\t\t\t\tctx.force = ctx.opt.force;\n\t\t\t\tif(cb !== ctx.cb){ ctx.cb.no = true }\n\t\t\t\tif(!Gun.obj.is(ctx.lex)){ return ctx.cb.call(gun = gun.chain(), {err: Gun.log('Invalid get request!', lex)}), gun }\n\t\t\t\tif(!(ctx.soul = ctx.lex[Gun._.soul])){ return ctx.cb.call(gun = this.chain(), {err: Gun.log('No soul to get!')}), gun } // TODO: With `.all` it'll be okay to not have an exact match!\n\t\t\t\tctx.by = gun.__.by(ctx.soul);\n\t\t\t\tctx.by.chain = ctx.by.chain || gun.chain();\n\t\t\t\tfunction load(lex){\n\t\t\t\t\tvar soul = lex[Gun._.soul];\n\t\t\t\t\tvar cached = gun.__.by(soul).node || gun.__.graph[soul];\n\t\t\t\t\tif(ctx.force){ ctx.force = false }\n\t\t\t\t\telse if(cached){ return false }\n\t\t\t\t\twire(lex, stream, ctx.opt);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfunction stream(err, data, info){\n\t\t\t\t\t//console.log(\"wire.get <--\", err, data);\n\t\t\t\t\tGun.on('wire.get').emit(ctx.by.chain, ctx, err, data, info);\n\t\t\t\t\tif(err){\n\t\t\t\t\t\tGun.log(err.err || err);\n\t\t\t\t\t\tctx.cb.call(ctx.by.chain, err);\n\t\t\t\t\t\treturn ctx.by.chain._.at('err').emit({soul: ctx.soul, err: err.err || err}).chain(ctx.opt.chain);\n\t\t\t\t\t}\n\t\t\t\t\tif(!data){\n\t\t\t\t\t\tctx.cb.call(ctx.by.chain, null);\n\t\t\t\t\t\treturn ctx.by.chain._.at('null').emit({soul: ctx.soul, not: true}).chain(ctx.opt.chain);\n\t\t\t\t\t}\n\t\t\t\t\tif(Gun.obj.empty(data)){ return }\n\t\t\t\t\tif(err = Gun.union(ctx.by.chain, data).err){\n\t\t\t\t\t\tctx.cb.call(ctx.by.chain, err);\n\t\t\t\t\t\treturn ctx.by.chain._.at('err').emit({soul: Gun.is.node.soul(data) || ctx.soul, err: err.err || err}).chain(ctx.opt.chain);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfunction wire(lex, cb, opt){\n\t\t\t\t\tGun.on('get.wire').emit(ctx.by.chain, ctx, lex, cb, opt);\n\t\t\t\t\tif(Gun.fns.is(gun.__.opt.wire.get)){ return gun.__.opt.wire.get(lex, cb, opt) }\n\t\t\t\t\tif(!Gun.log.count('no-wire-get')){ Gun.log(\"Warning! You have no persistence layer to get from!\") }\n\t\t\t\t\tcb(null); // This is in memory success, hardly \"success\" at all.\n\t\t\t\t}\n\t\t\t\tfunction on(at){\n\t\t\t\t\tif(on.ran = true){ ctx.opt.on = this }\n\t\t\t\t\tif(load(ctx.lex)){ return }\n\t\t\t\t\tGun.on('get').emit(ctx.by.chain, at, ctx, ctx.opt, ctx.cb, ctx.lex);\n\t\t\t\t}\n\t\t\t\tctx.opt.on = (ctx.opt.at || gun.__.at)(ctx.soul).event(on);\n\t\t\t\tctx.by.chain._.get = ctx.lex;\n\t\t\t\tif(!ctx.opt.ran && !on.ran){ on.call(ctx.opt.on, {soul: ctx.soul}) }\n\t\t\t\treturn ctx.by.chain;\n\t\t\t}\n\t\t}());\n\n\t\tGun.chain.key = (function(){\n\t\t\tGun.on('put').event(function(gun, at, ctx, opt, cb){\n\t\t\t\tif(opt.key){ return }\n\t\t\t\tGun.is.graph(ctx.ify.graph, function(node, soul){\n\t\t\t\t\tvar key = {node: gun.__.graph[soul]};\n\t\t\t\t\tif(!Gun.is.node.soul(key.node, 'key')){ return }\n\t\t\t\t\tif(!gun.__.by(soul).end){ gun.__.by(soul).end = 1 }\n\t\t\t\t\tGun.is.node(key.node, function each(rel, s){\n\t\t\t\t\t\tvar n = gun.__.graph[s];\n\t\t\t\t\t\tif(n && Gun.is.node.soul(n, 'key')){\n\t\t\t\t\t\t\tGun.is.node(n, each);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trel = ctx.ify.graph[s] = ctx.ify.graph[s] || Gun.is.node.soul.ify({}, s);\n\t\t\t\t\t\tGun.is.node(node, function(v,f){ Gun.is.node.state.ify([rel, node], f, v) });\n\t\t\t\t\t\tGun.obj.del(ctx.ify.graph, soul);\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t});\n\t\t\tGun.on('get').event(function(gun, at, ctx, opt, cb){\n\t\t\t\tif(ctx.halt){ return } // TODO: CLEAN UP with event emitter option?\n\t\t\t\tif(opt.key && opt.key.soul){\n\t\t\t\t\tat.soul = opt.key.soul;\n\t\t\t\t\tgun.__.by(opt.key.soul).node = Gun.union.ify(gun, opt.key.soul); // TODO: Check performance?\n\t\t\t\t\tgun.__.by(opt.key.soul).node._['key'] = 'pseudo';\n\t\t\t\t\tat.change = Gun.is.node.soul.ify(Gun.obj.copy(at.change || gun.__.by(at.soul).node), at.soul, true); // TODO: Check performance?\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(!(Gun.is.node.soul(gun.__.graph[at.soul], 'key') === 1)){ return }\n\t\t\t\tvar node = at.change || gun.__.graph[at.soul];\n\t\t\t\tfunction map(rel, soul){ gun.__.gun.get(rel, cb, {key: ctx, chain: opt.chain || gun, force: opt.force}) }\n\t\t\t\tctx.halt = true;\n\t\t\t\tGun.is.node(node, map);\n\t\t\t},-999);\n\t\t\treturn function(key, cb, opt){\n\t\t\t\tvar gun = this;\n\t\t\t\topt = Gun.text.is(opt)? {soul: opt} : opt || {};\n\t\t\t\tcb = cb || function(){}; cb.hash = {};\n\t\t\t\tif(!Gun.text.is(key) || !key){ return cb.call(gun, {err: Gun.log('No key!')}), gun }\n\t\t\t\tfunction index(at){\n\t\t\t\t\tvar ctx = {node: gun.__.graph[at.soul]};\n\t\t\t\t\tif(at.soul === key || at.key === key){ return }\n\t\t\t\t\tif(cb.hash[at.hash = at.hash || Gun.on.at.hash(at)]){ return } cb.hash[at.hash] = true;\n\t\t\t\t\tctx.obj = (1 === Gun.is.node.soul(ctx.node, 'key'))? Gun.obj.copy(ctx.node) : Gun.obj.put({}, at.soul, Gun.is.rel.ify(at.soul));\n\t\t\t\t\tGun.obj.as((ctx.put = Gun.is.node.ify(ctx.obj, key, true))._, 'key', 1);\n\t\t\t\t\tgun.__.gun.put(ctx.put, function(err, ok){cb.call(this, err, ok)}, {chain: opt.chain, key: true, init: true});\n\t\t\t\t}\n\t\t\t\tif(opt.soul){\n\t\t\t\t\tindex({soul: opt.soul});\n\t\t\t\t\treturn gun;\n\t\t\t\t}\n\t\t\t\tif(gun === gun.back){\n\t\t\t\t\tcb.call(gun, {err: Gun.log('You have no context to `.key`', key, '!')});\n\t\t\t\t} else {\n\t\t\t\t\tgun._.at('soul').map(index);\n\t\t\t\t}\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t}());\n\n\t\tGun.chain.on = function(cb, opt){ // on subscribes to any changes on the souls.\n\t\t\tvar gun = this, u, oldoff = this.off;\n\t\t\topt = Gun.obj.is(opt)? opt : {change: opt};\n\t\t\tcb = cb || function(){};\n\t\t\tfunction map(at){\n\t\t\t\topt.on = opt.on || this;\n\t\t\t\tvar ctx = {by: gun.__.by(at.soul)}, change = ctx.by.node;\n\t\t\t\tif(opt.on.stat && opt.on.stat.first){ (at = Gun.on.at.copy(at)).change = ctx.by.node }\n\t\t\t\tif(opt.raw){ return cb.call(opt.on, at) }\n\t\t\t\tif(opt.once){ this.off() }\n\t\t\t\tif(opt.change){ change = at.change }\n\t\t\t\tif(!opt.empty && Gun.obj.empty(change, Gun._.meta)){ return }\n\t\t\t\tcb.call(ctx.by.chain || gun, Gun.obj.copy(at.field? change[at.field] : change), at.field || (at.at && at.at.field));\n\t\t\t};\n\t\t\topt.on = gun._.at('soul').map(map);\n\t\t\tif(gun === gun.back){ Gun.log('You have no context to `.on`!') }\n\t\t\tgun.off = oldoff ? function() { oldoff(); opt.on.off(); } : opt.on.off // Chain offs\n\t\t\treturn gun;\n\t\t}\n\n\t\tGun.chain.path = (function(){\n\t\t\tGun.on('get').event(function(gun, at, ctx, opt, cb, lex){\n\t\t\t\tif(ctx.halt){ return } // TODO: CLEAN UP with event emitter option?\n\t\t\t\tif(opt.path){ at.at = opt.path }\n\t\t\t\tvar xtc = {soul: lex[Gun._.soul], field: lex[Gun._.field]};\n\t\t\t\txtc.change = at.change || gun.__.by(at.soul).node;\n\t\t\t\tif(xtc.field){ // TODO: future feature!\n\t\t\t\t\tif(!Gun.obj.has(xtc.change, xtc.field)){ return }\n\t\t\t\t\tctx.node = Gun.is.node.soul.ify({}, at.soul); // TODO: CLEAN UP! ctx.node usage.\n\t\t\t\t\tGun.is.node.state.ify([ctx.node, xtc.change], xtc.field, xtc.change[xtc.field]);\n\t\t\t\t\tat.change = ctx.node; at.field = xtc.field;\n\t\t\t\t}\n\t\t\t},-99);\n\t\t\tGun.on('get').event(function(gun, at, ctx, opt, cb, lex){\n\t\t\t\tif(ctx.halt){ return } // TODO: CLEAN UP with event emitter option?\n\t\t\t\tvar xtc = {}; xtc.change = at.change || gun.__.by(at.soul).node;\n\t\t\t\tif(!opt.put){ // TODO: CLEAN UP be nice if path didn't have to worry about this.\n\t\t\t\t\tGun.is.node(xtc.change, function(v,f){\n\t\t\t\t\t\tvar fat = Gun.on.at.copy(at); fat.field = f; fat.value = v;\n\t\t\t\t\t\tGun.obj.del(fat, 'at'); // TODO: CLEAN THIS UP! It would be nice in every other function every where else it didn't matter whether there was a cascading at.at.at.at or not, just and only whether the current context as a field or should rely on a previous field. But maybe that is the gotcha right there?\n\t\t\t\t\t\tfat.change = fat.change || xtc.change;\n\t\t\t\t\t\tif(v = Gun.is.rel(fat.value)){ fat = {soul: v, at: fat} }\n\t\t\t\t\t\tgun._.at('path:' + f).emit(fat).chain(opt.chain);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif(!ctx.end){\n\t\t\t\t\tctx.end = gun._.at('end').emit(at).chain(opt.chain);\n\t\t\t\t}\n\t\t\t},99);\n\t\t\treturn function(path, cb, opt){\n\t\t\t\topt = opt || {};\n\t\t\t\tcb = cb || (function(){ var cb = function(){}; cb.no = true; return cb }()); cb.hash = {};\n\t\t\t\tvar gun = this, chain = gun.chain(), ons = [], f, c, u;\n\t\t\t\tif(!Gun.list.is(path)){ if(!Gun.text.is(path)){ if(!Gun.num.is(path)){ // if not a list, text, or number\n\t\t\t\t\treturn cb.call(chain, {err: Gun.log(\"Invalid path '\" + path + \"'!\")}), chain; // then complain\n\t\t\t\t} else { return this.path(path + '', cb, opt)  } } else { return this.path(path.split('.'), cb, opt) } } // else coerce upward to a list.\n\t\t\t\tif(gun === gun.back){\n\t\t\t\t\tcb.call(chain, opt.put? null : {err: Gun.log('You have no context to `.path`', path, '!')}, opt.put? gun.__.graph[(path||[])[0]] : u);\n\t\t\t\t\treturn chain;\n\t\t\t\t}\n\t\t\t\tons.push(gun._.at('path:' + path[0]).event(function(at){\n\t\t\t\t\tif(opt.done){ this.off(); return } // TODO: BUG - THIS IS A FIX FOR A BUG! TEST #\"context no double emit\", COMMENT THIS LINE OUT AND SEE IT FAIL!\n\t\t\t\t\tvar ctx = {soul: at.soul, field: at.field, by: gun.__.by(at.soul)}, field = path[0];\n\t\t\t\t\tvar on = Gun.obj.as(cb.hash, at.hash, {off: function(){}});\n\t\t\t\t\tif(at.soul === on.soul){ return }\n\t\t\t\t\telse { on.off() }\n\t\t\t\t\tif(ctx.rel = (Gun.is.rel(at.value) || Gun.is.rel(at.at && at.at.value))){\n\t\t\t\t\t\tif(opt.put && 1 === path.length){\n\t\t\t\t\t\t\treturn cb.call(ctx.by.chain || chain, null, Gun.is.node.soul.ify({}, ctx.rel));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar get = function(err, node){\n\t\t\t\t\t\t\tif(!err && 1 !== path.length){ return }\n\t\t\t\t\t\t\tcb.call(this, err, node, field);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tctx.opt = {chain: opt.chain || chain, put: opt.put, path: {soul: (at.at && at.at.soul) || at.soul, field: field }};\n\t\t\t\t\t\tgun.__.gun.get(ctx.rel || at.soul, cb.no? null : get, ctx.opt);\n\t\t\t\t\t\t(opt.on = cb.hash[at.hash] = on = ctx.opt.on).soul = at.soul; // TODO: BUG! CB getting reused as the hash point for multiple paths potentially! Could cause problems!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(1 === path.length){ cb.call(ctx.by.chain || chain, null, at.value, ctx.field) }\n\t\t\t\t\tchain._.at('soul').emit(at).chain(opt.chain);\n\t\t\t\t}));\n\t\t\t\tons.push(gun._.at('null').only(function(at){\n\t\t\t\t\tif(!at.field){ return }\n\t\t\t\t\tif(at.not){\n\t\t\t\t\t\tgun.put({}, null, {init: true});\n\t\t\t\t\t\tif(opt.init || gun.__.opt.init){ return }\n\t\t\t\t\t}\n\t\t\t\t\t(at = Gun.on.at.copy(at)).field = path[0];\n\t\t\t\t\tat.not = true;\n\t\t\t\t\tchain._.at('null').emit(at).chain(opt.chain);\n\t\t\t\t}));\n\t\t\t\tons.push(gun._.at('end').event(function(at){\n\t\t\t\t\tthis.off();\n\t\t\t\t\tif(at.at && at.at.field === path[0]){ return } // TODO: BUG! THIS FIXES SO MANY PROBLEMS BUT DOES IT CATCH VARYING SOULS EDGE CASE?\n\t\t\t\t\tvar ctx = {by: gun.__.by(at.soul)};\n\t\t\t\t\tif(Gun.obj.has(ctx.by.node, path[0])){ return }\n\t\t\t\t\t(at = Gun.on.at.copy(at)).field = path[0];\n\t\t\t\t\tat.not = true;\n\t\t\t\t\tcb.call(ctx.by.chain || chain, null);\n\t\t\t\t\tchain._.at('null').emit(at).chain(opt.chain);\n\t\t\t\t}));\n\t\t\t\tif(path.length > 1){\n\t\t\t\t\t(c = chain.path(path.slice(1), cb, opt)).back = gun;\n\t\t\t\t}\n\t\t\t\t(c || chain).off = function() {\n\t\t\t\t\tons.forEach(function(on) {\n\t\t\t\t\t\ton.off();\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\treturn c || chain;\n\t\t\t}\n\t\t}());\n\n\t\tGun.chain.map = function(cb, opt){\n\t\t\tvar u, gun = this, chain = gun.chain();\n\t\t\tcb = cb || function(){}; cb.hash = {};\n\t\t\topt = Gun.bi.is(opt)? {change: opt} : opt || {};\n\t\t\topt.change = Gun.bi.is(opt.change)? opt.change : true;\n\t\t\tfunction path(err, val, field){\n\t\t\t\tif(err || (val === u)){ return }\n\t\t\t\tcb.call(this, val, field);\n\t\t\t}\n\t\t\tfunction each(val, field){\n\t\t\t\t//if(!Gun.is.rel(val)){ path.call(this.gun, null, val, field);return;}\n\t\t\t\tif(opt.node){\n\t\t\t\t\tif(!Gun.is.rel(val)){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcb.hash[this.soul + field] = cb.hash[this.soul + field] || (pathon = this.gun.path(field, path, {chain: chain, via: 'map'})); // TODO: path should reuse itself! We shouldn't have to do it ourselves.\n\t\t\t\t// TODO:\n\t\t\t\t// 1. Ability to turn off an event. // automatically happens within path since reusing is manual?\n\t\t\t\t// 2. Ability to pass chain context to fire on. // DONE\n\t\t\t\t// 3. Pseudoness handled for us. // DONE\n\t\t\t\t// 4. Reuse. // MANUALLY DONE\n\t\t\t}\n\t\t\tfunction map(at){\n\t\t\t\tvar ref = gun.__.by(at.soul).chain || gun;\n\t\t\t\tGun.is.node(at.change, each, {gun: ref, soul: at.soul});\n\t\t\t}\n\t\t\ton = gun.on(map, {raw: true, change: true}); // TODO: ALLOW USER TO DO map change false!\n\t\t\tchain.off = function() {\n\t\t\t\tif (pathon) pathon.off();\n\t\t\t\ton.off();\n\t\t\t}\n\t\t\tif(gun === gun.back){ Gun.log('You have no context to `.map`!') }\n\t\t\treturn chain;\n\t\t}\n\n\t\tGun.chain.val = (function(){\n\t\t\tGun.on('get.wire').event(function(gun, ctx){\n\t\t\t\tif(!ctx.soul){ return } var end;\n\t\t\t\t(end = gun.__.by(ctx.soul)).end = (end.end || -1); // TODO: CLEAN UP! This should be per peer!\n\t\t\t},-999);\n\t\t\tGun.on('wire.get').event(function(gun, ctx, err, data){\n\t\t\t\tif(err || !ctx.soul){ return }\n\t\t\t\tif(data && !Gun.obj.empty(data, Gun._.meta)){ return }\n\t\t\t\tvar end = gun.__.by(ctx.soul);\n\t\t\t\tend.end = (!end.end || end.end < 0)? 1 : end.end + 1;\n\t\t\t},-999);\n\t\t\treturn function(cb, opt){\n\t\t\t\tvar gun = this, args = Gun.list.slit.call(arguments);\n\t\t\t\tcb = Gun.fns.is(cb)? cb : function(val, field){ root.console.log.apply(root.console, args.concat([field && (field += ':'), val])) }; cb.hash = {};\n\t\t\t\topt = opt || {};\n\t\t\t\tfunction val(at){\n\t\t\t\t\tvar ctx = {by: gun.__.by(at.soul), at: at.at || at}, node = ctx.by.node, field = ctx.at.field, hash = Gun.on.at.hash({soul: ctx.at.key || ctx.at.soul, field: field});\n\t\t\t\t\tif(cb.hash[hash]){ return }\n\t\t\t\t\tif(at.field && Gun.obj.has(node, at.field)){\n\t\t\t\t\t\treturn cb.hash[hash] = true, cb.call(ctx.by.chain || gun, Gun.obj.copy(node[at.field]), at.field);\n\t\t\t\t\t}\n\t\t\t\t\tif(!opt.empty && Gun.obj.empty(node, Gun._.meta)){ return } // TODO: CLEAN UP! .on already does this without the .raw!\n\t\t\t\t\tif(ctx.by.end < 0){ return }\n\t\t\t\t\treturn cb.hash[hash] = true, cb.call(ctx.by.chain || gun, Gun.obj.copy(node), field);\n\t\t\t\t}\n\t\t\t\tgun.on(val, {raw: true});\n\t\t\t\tif(gun === gun.back){ Gun.log('You have no context to `.val`!') }\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t}());\n\n\t\tGun.chain.not = function(cb, opt){\n\t\t\tvar gun = this, chain = gun.chain();\n\t\t\tcb = cb || function(){};\n\t\t\topt = opt || {};\n\t\t\tfunction not(at,e){\n\t\t\t\tif(at.field){\n\t\t\t\t\tif(Gun.obj.has(gun.__.by(at.soul).node, at.field)){ return Gun.obj.del(at, 'not'), chain._.at(e).emit(at) }\n\t\t\t\t} else\n\t\t\t\tif(at.soul && gun.__.by(at.soul).node){ return Gun.obj.del(at, 'not'), chain._.at(e).emit(at) }\n\t\t\t\tif(!at.not){ return }\n\t\t\t\tvar kick = function(next){\n\t\t\t\t\tif(++kick.c){ return Gun.log(\"Warning! Multiple `not` resumes!\"); }\n\t\t\t\t\tnext._.at.all(function(on ,e){ // TODO: BUG? Switch back to .at? I think .on is actually correct so it doesn't memorize. // TODO: BUG! What about other events?\n\t\t\t\t\t\tchain._.at(e).emit(on);\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tkick.c = -1\n\t\t\t\tkick.chain = gun.chain();\n\t\t\t\tkick.next = cb.call(kick.chain, opt.raw? at : (at.field || at.soul || at.not), kick);\n\t\t\t\tkick.soul = Gun.text.random();\n\t\t\t\tif(Gun.is(kick.next)){ kick(kick.next) }\n\t\t\t\tkick.chain._.at('soul').emit({soul: kick.soul, field: at.field, not: true, via: 'not'});\n\t\t\t}\n\t\t\tgun._.at.all(not);\n\t\t\tif(gun === gun.back){ Gun.log('You have no context to `.not`!') }\n\t\t\tchain._.not = true; // TODO: CLEAN UP! Would be ideal if we could accomplish this in a more elegant way.\n\t\t\treturn chain;\n\t\t}\n\n\t\tGun.chain.set = function(item, cb, opt){\n\t\t\tvar gun = this, ctx = {}, chain, rel;\n\t\t\tcb = cb || function(){};\n\t\t\tif(Gun.is.node(item) && (rel=Gun.is.rel(item._))){\n\t\t\t\t// Resolve set with a node\n\t\t\t\treturn gun.set(gun.get(rel), cb, opt);\n\t\t\t}\n\t\t\tif(typeof(item)=='object'&&!Gun.is(item)&&!Gun.is.rel(item)&&!Gun.is.lex(item)&&!Gun.is.node(item)&&!Gun.is.graph(item)){\n\t\t\t\t// Resolve set with a new soul\n\t\t\t\treturn gun.set(Gun.root(gun).put(item), cb, opt);\n\t\t\t}\n\t\t\tif(!Gun.is(item)){ return cb.call(gun, {err: Gun.log('Set only supports node references currently!')}), gun } // TODO: Bug? Should we return not gun on error?\n\t\t\t(ctx.chain = item.chain()).back = gun;\n\t\t\tctx.chain._ = item._;\n\t\t\titem.val(function(node){ // TODO: BUG! Return proxy chain with back = list.\n\t\t\t\tif(ctx.done){ return } ctx.done = true;\n\t\t\t\tvar put = {}, soul = Gun.is.node.soul(node);\n\t\t\t\tif(!soul){ return cb.call(gun, {err: Gun.log('Only a node can be linked! Not \"' + node + '\"!')}) }\n\t\t\t\tgun.put(Gun.obj.put(put, soul, Gun.is.rel.ify(soul)), cb, opt);\n\t\t\t});\n\t\t\treturn ctx.chain;\n\t\t}\n\n\t\tGun.chain.init = function(cb, opt){\n\t\t\tvar gun = this;\n\t\t\tgun._.at('null').event(function(at){\n\t\t\t\tif(!at.not){ return } // TODO: BUG! This check is synchronous but it could be asynchronous!\n\t\t\t\tvar ctx = {by: gun.__.by(at.soul)};\n\t\t\t\tthis.off();\n\t\t\t\tif(at.field){\n\t\t\t\t\tif(Gun.obj.has(ctx.by.node, at.field)){ return }\n\t\t\t\t\tgun._.at('soul').emit({soul: at.soul, field: at.field, not: true});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(at.soul){\n\t\t\t\t\tif(ctx.by.node){ return }\n\t\t\t\t\tvar soul = Gun.text.random();\n\t\t\t\t\tgun.__.gun.put(Gun.is.node.soul.ify({}, soul), null, {init: true});\n\t\t\t\t\tgun.__.gun.key(at.soul, null, soul);\n\t\t\t\t}\n\t\t\t}, {raw: true});\n\t\t\treturn gun;\n\t\t}\n\n\t}(Gun));\n\n\t;(function(Gun){ // Javascript to Gun Serializer.\n\t\tfunction ify(data, cb, opt){\n\t\t\topt = opt || {};\n\t\t\tcb = cb || function(env, cb){ cb(env.at, Gun.is.node.soul(env.at.obj) || Gun.is.node.soul(env.at.node) || Gun.text.random()) };\n\t\t\tvar end = function(fn){\n\t\t\t\tctx.end = fn || function(){};\n\t\t\t\tunique(ctx);\n\t\t\t}, ctx = {at: {path: [], obj: data}, root: {}, graph: {}, queue: [], seen: [], opt: opt, loop: true};\n\t\t\tif(!data){ return ctx.err = {err: Gun.log('Serializer does not have correct parameters.')}, end }\n\t\t\tif(ctx.opt.start){ Gun.is.node.soul.ify(ctx.root, ctx.opt.start) }\n\t\t\tctx.at.node = ctx.root;\n\t\t\twhile(ctx.loop && !ctx.err){\n\t\t\t\tseen(ctx, ctx.at);\n\t\t\t\tmap(ctx, cb);\n\t\t\t\tif(ctx.queue.length){\n\t\t\t\t\tctx.at = ctx.queue.shift();\n\t\t\t\t} else {\n\t\t\t\t\tctx.loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn end;\n\t\t}\n\t\tfunction map(ctx, cb){\n\t\t\tvar u, rel = function(at, soul){\n\t\t\t\tat.soul = at.soul || soul || Gun.is.node.soul(at.obj) || Gun.is.node.soul(at.node);\n\t\t\t\tif(!ctx.opt.pure){\n\t\t\t\t\tctx.graph[at.soul] = Gun.is.node.soul.ify(at.node, at.soul);\n\t\t\t\t\tif(ctx.at.field){\n\t\t\t\t\t\tGun.is.node.state.ify([at.node], at.field, u, ctx.opt.state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGun.list.map(at.back, function(rel){\n\t\t\t\t\trel[Gun._.soul] = at.soul;\n\t\t\t\t});\n\t\t\t\tunique(ctx);\n\t\t\t}, it;\n\t\t\tGun.obj.map(ctx.at.obj, function(val, field){\n\t\t\t\tctx.at.val = val;\n\t\t\t\tctx.at.field = field;\n\t\t\t\tit = cb(ctx, rel, map) || true;\n\t\t\t\tif(field === Gun._.meta){\n\t\t\t\t\tctx.at.node[field] = Gun.obj.copy(val); // TODO: BUG! Is this correct?\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(String(field).indexOf('.') != -1 || (false && notValidField(field))){ // TODO: BUG! Do later for ACID \"consistency\" guarantee.\n\t\t\t\t\treturn ctx.err = {err: Gun.log(\"Invalid field name on '\" + ctx.at.path.join('.') + \"'!\")};\n\t\t\t\t}\n\t\t\t\tif(!Gun.is.val(val)){\n\t\t\t\t\tvar at = {obj: val, node: {}, back: [], path: [field]}, tmp = {}, was;\n\t\t\t\t\tat.path = (ctx.at.path||[]).concat(at.path || []);\n\t\t\t\t\tif(!Gun.obj.is(val)){\n\t\t\t\t\t\treturn ctx.err = {err: Gun.log(\"Invalid value at '\" + at.path.join('.') + \"'!\" )};\n\t\t\t\t\t}\n\t\t\t\t\tif(was = seen(ctx, at)){\n\t\t\t\t\t\ttmp[Gun._.soul] = Gun.is.node.soul(was.node) || null;\n\t\t\t\t\t\t(was.back = was.back || []).push(ctx.at.node[field] = tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.queue.push(at);\n\t\t\t\t\t\ttmp[Gun._.soul] = null;\n\t\t\t\t\t\tat.back.push(ctx.at.node[field] = tmp);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tctx.at.node[field] = Gun.obj.copy(val);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(!it){ cb(ctx, rel) }\n\t\t}\n\t\tfunction unique(ctx){\n\t\t\tif(ctx.err || (!Gun.list.map(ctx.seen, function(at){\n\t\t\t\tif(!at.soul){ return true }\n\t\t\t}) && !ctx.loop)){ return ctx.end(ctx.err, ctx), ctx.end = function(){}; }\n\t\t}\n\t\tfunction seen(ctx, at){\n\t\t\treturn Gun.list.map(ctx.seen, function(has){\n\t\t\t\tif(at.obj === has.obj){ return has }\n\t\t\t}) || (ctx.seen.push(at) && false);\n\t\t}\n\t\tify.wire = function(n, cb, opt){ return Gun.text.is(n)? ify.wire.from(n, cb, opt) : ify.wire.to(n, cb, opt) }\n\t\tify.wire.to = function(n, cb, opt){ var t, b;\n\t\t\tif(!n || !(t = Gun.is.node.soul(n))){ return null }\n\t\t\tcb = cb || function(){};\n\t\t\tt = (b = \"#'\" + JSON.stringify(t) + \"'\");\n\t\t\tGun.obj.map(n, function(v,f){\n\t\t\t\tif(Gun._.meta === f){ return }\n\t\t\t\tvar w = '', s = Gun.is.node.state(n,f);\n\t\t\t\tif(!s){ return }\n\t\t\t\tw += \".'\" + JSON.stringify(f) + \"'\";\n\t\t\t\tw += \"='\" + JSON.stringify(v) + \"'\";\n\t\t\t\tw += \">'\" + JSON.stringify(s) + \"'\";\n\t\t\t\tt += w;\n\t\t\t\tw = b + w;\n\t\t\t\tcb(null, w);\n\t\t\t});\n\t\t\treturn t;\n\t\t}\n\t\tify.wire.from = function(n, cb, opt){\n\t\t\tif(!n){ return null }\n\t\t\tvar a = [], s = -1, e = 0, end = 1;\n\t\t\twhile((e = n.indexOf(\"'\", s + 1)) >= 0){\n\t\t\t\tif(s === e || '\\\\' === n.charAt(e-1)){}else{\n\t\t\t\t\ta.push(n.slice(s + 1,e));\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tGun.ify = ify;\n\t}(Gun));\n\n\tvar root = this || {}; // safe for window, global, root, and 'use strict'.\n\tif(typeof window !== \"undefined\"){ (root = window).Gun = Gun }\n\tif(typeof module !== \"undefined\" && module.exports){ module.exports = Gun }\n\tif(typeof global !== \"undefined\"){ root = global; }\n\troot.console = root.console || {log: function(s){ return s }}; // safe for old browsers\n\tvar console = {\n\t\tlog: function(s){return root.console.log.apply(root.console, arguments), s},\n\t\tLog: Gun.log = function(s){ return (!Gun.log.squelch && root.console.log.apply(root.console, arguments)), s }\n\t};\n\tconsole.debug = function(i, s){ return (Gun.log.debug && i === Gun.log.debug && Gun.log.debug++) && root.console.log.apply(root.console, arguments), s };\n\tGun.log.count = function(s){ return Gun.log.count[s] = Gun.log.count[s] || 0, Gun.log.count[s]++ }\n}.bind(this || module)());\n\n\n;(function(Tab){\n\n\tif(typeof window === \"undefined\"){ return; }\n\tif(!window.Gun){ return }\n\tif(!window.JSON){ throw new Error(\"Include JSON first: ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js\") } // for old IE use\n\n\t;(function(exports){\n\t\tfunction s(){}\n\t\ts.put = function(key, val, cb){ try{ store.setItem(key, Gun.text.ify(val)) }catch(e){if(cb)cb(e)} }\n\t\ts.get = function(key, cb){ /*setTimeout(function(){*/ try{ cb(null, Gun.obj.ify(store.getItem(key) || null)) }catch(e){cb(e)} /*},1)*/}\n\t\ts.del = function(key){ return store.removeItem(key) }\n\t\t// Feature detect + local reference\n\t\tvar storage;\n\t\tvar fail;\n\t\tvar uid;\n\t\ttry {\n\t\t\tuid = new Date;\n\t\t\t(storage = window.localStorage).setItem(uid, uid);\n\t\t\tfail = storage.getItem(uid) != uid;\n\t\t\tstorage.removeItem(uid);\n\t\t\tfail && (storage = false);\n\t\t} catch (exception) {}\n\t\tvar store = (storage && window.localStorage) || {setItem: function(){}, removeItem: function(){}, getItem: function(){}};\n\t\texports.store = s;\n\t}.bind(this || module)(Tab));\n\n\tGun.on('opt').event(function(gun, opt){\n\t\topt = opt || {};\n\t\tvar tab = gun.tab = gun.tab || {};\n\t\ttab.store = tab.store || Tab.store;\n\t\ttab.request = tab.request || Gun.request;\n\t\tif(!tab.request){ throw new Error(\"Default GUN driver could not find default network abstraction.\") }\n\t\ttab.request.s = tab.request.s || {};\n\t\ttab.headers = opt.headers || {};\n\t\ttab.headers['gun-sid'] = tab.headers['gun-sid'] || Gun.text.random(); // stream id\n\t\ttab.prefix = tab.prefix || opt.prefix || 'gun/';\n\t\ttab.get = tab.get || function(lex, cb, opt){\n\t\t\tif(!lex){ return }\n\t\t\tvar soul = lex[Gun._.soul];\n\t\t\tif(!soul){ return }\n\t\t\tcb = cb || function(){};\n\t\t\tvar ropt = {};\n\t\t\t(ropt.headers = Gun.obj.copy(tab.headers)).id = tab.msg();\n\t\t\t(function local(soul, cb){\n\t\t\t\ttab.store.get(tab.prefix + soul, function(err, data){\n\t\t\t\t\tif(!data){ return } // let the peers handle no data.\n\t\t\t\t\tif(err){ return cb(err) }\n\t\t\t\t\tcb(err, cb.node = data); // node\n\t\t\t\t\tcb(err, Gun.is.node.soul.ify({}, Gun.is.node.soul(data))); // end\n\t\t\t\t\tcb(err, {}); // terminate\n\t\t\t\t});\n\t\t\t}(soul, cb));\n\t\t\tif(!(cb.local = opt.local)){\n\t\t\t\ttab.request.s[ropt.headers.id] = tab.error(cb, \"Error: Get failed!\", function(reply){\n\t\t\t\t\tsetTimeout(function(){ tab.put(Gun.is.graph.ify(reply.body), function(){}, {local: true, peers: {}}) },1); // and flush the in memory nodes of this graph to localStorage after we've had a chance to union on it.\n\t\t\t\t});\n\t\t\t\tGun.obj.map(opt.peers || gun.__.opt.peers, function(peer, url){ var p = {};\n\t\t\t\t\ttab.request(url, lex, tab.request.s[ropt.headers.id], ropt);\n\t\t\t\t\tcb.peers = true;\n\t\t\t\t});\n\t\t\t\tvar node = gun.__.graph[soul];\n\t\t\t\tif(node){\n\t\t\t\t\ttab.put(Gun.is.graph.ify(node));\n\t\t\t\t}\n\t\t\t} tab.peers(cb);\n\t\t}\n\t\ttab.put = tab.put || function(graph, cb, opt){\n\t\t\tcb = cb || function(){};\n\t\t\topt = opt || {};\n\t\t\tvar ropt = {};\n\t\t\t(ropt.headers = Gun.obj.copy(tab.headers)).id = tab.msg();\n\t\t\tGun.is.graph(graph, function(node, soul){\n\t\t\t\tif(!gun.__.graph[soul]){ return }\n\t\t\t\ttab.store.put(tab.prefix + soul, gun.__.graph[soul], function(err){if(err){ cb({err: err}) }});\n\t\t\t});\n\t\t\tif(!(cb.local = opt.local)){\n\t\t\t\ttab.request.s[ropt.headers.id] = tab.error(cb, \"Error: Put failed!\");\n\t\t\t\tGun.obj.map(opt.peers || gun.__.opt.peers, function(peer, url){\n\t\t\t\t\ttab.request(url, graph, tab.request.s[ropt.headers.id], ropt);\n\t\t\t\t\tcb.peers = true;\n\t\t\t\t});\n\t\t\t} tab.peers(cb);\n\t\t}\n\t\ttab.error = function(cb, error, fn){\n\t\t\treturn function(err, reply){\n\t\t\t\treply.body = reply.body || reply.chunk || reply.end || reply.write;\n\t\t\t\tif(err || !reply || (err = reply.body && reply.body.err)){\n\t\t\t\t\treturn cb({err: Gun.log(err || error) });\n\t\t\t\t}\n\t\t\t\tif(fn){ fn(reply) }\n\t\t\t\tcb(null, reply.body);\n\t\t\t}\n\t\t}\n\t\ttab.peers = function(cb, o){\n\t\t\tif(Gun.text.is(cb)){ return (o = {})[cb] = {}, o }\n\t\t\tif(cb && !cb.peers){ setTimeout(function(){\n\t\t\t\tif(!cb.local){ if(!Gun.log.count('no-peers')){ Gun.log(\"Warning! You have no peers to connect to!\") } }\n\t\t\t\tif(!(cb.graph || cb.node)){ cb(null) }\n\t\t\t},1)}\n\t\t}\n\t\ttab.msg = tab.msg || function(id){\n\t\t\tif(!id){\n\t\t\t\treturn tab.msg.debounce[id = Gun.text.random(9)] = Gun.time.is(), id;\n\t\t\t}\n\t\t\tclearTimeout(tab.msg.clear);\n\t\t\ttab.msg.clear = setTimeout(function(){\n\t\t\t\tvar now = Gun.time.is();\n\t\t\t\tGun.obj.map(tab.msg.debounce, function(t,id){\n\t\t\t\t\tif(now - t < 1000 * 60 * 5){ return }\n\t\t\t\t\tGun.obj.del(tab.msg.debounce, id);\n\t\t\t\t});\n\t\t\t},500);\n\t\t\tif(id = tab.msg.debounce[id]){\n\t\t\t\treturn tab.msg.debounce[id] = Gun.time.is(), id;\n\t\t\t}\n\t\t};\n\t\ttab.msg.debounce = tab.msg.debounce || {};\n\t\ttab.server = tab.server || function(req, res){\n\t\t\tif(!req || !res || !req.body || !req.headers || !req.headers.id){ return }\n\t\t\tif(tab.request.s[req.headers.rid]){ return tab.request.s[req.headers.rid](null, req) }\n\t\t\tif(tab.msg(req.headers.id)){ return }\n\t\t\t// TODO: Re-emit message to other peers if we have any non-overlaping ones.\n\t\t\tif(req.headers.rid){ return } // no need to process\n\t\t\tif(Gun.is.lex(req.body)){ return tab.server.get(req, res) }\n\t\t\telse { return tab.server.put(req, res) }\n\t\t}\n\t\ttab.server.json = 'application/json';\n\t\ttab.server.regex = gun.__.opt.route = gun.__.opt.route || opt.route || /^\\/gun/i;\n\t\ttab.server.get = function(req, cb){\n\t\t\tvar soul = req.body[Gun._.soul], node;\n\t\t\tif(!(node = gun.__.graph[soul])){ return }\n\t\t\tvar reply = {headers: {'Content-Type': tab.server.json, rid: req.headers.id, id: tab.msg()}};\n\t\t\tcb({headers: reply.headers, body: node});\n\t\t}\n\t\ttab.server.put = function(req, cb){\n\t\t\tvar reply = {headers: {'Content-Type': tab.server.json, rid: req.headers.id, id: tab.msg()}}, keep;\n\t\t\tif(!req.body){ return cb({headers: reply.headers, body: {err: \"No body\"}}) }\n\t\t\tif(!Gun.obj.is(req.body, function(node, soul){\n\t\t\t\tif(gun.__.graph[soul]){ return true }\n\t\t\t})){ return }\n\t\t\tif(req.err = Gun.union(gun, req.body, function(err, ctx){\n\t\t\t\tif(err){ return cb({headers: reply.headers, body: {err: err || \"Union failed.\"}}) }\n\t\t\t\tvar ctx = ctx || {}; ctx.graph = {};\n\t\t\t\tGun.is.graph(req.body, function(node, soul){ ctx.graph[soul] = gun.__.graph[soul] });\n\t\t\t\tgun.__.opt.wire.put(ctx.graph, function(err, ok){\n\t\t\t\t\tif(err){ return cb({headers: reply.headers, body: {err: err || \"Failed.\"}}) }\n\t\t\t\t\tcb({headers: reply.headers, body: {ok: ok || \"Persisted.\"}});\n\t\t\t\t}, {local: true, peers: {}});\n\t\t\t}).err){ cb({headers: reply.headers, body: {err: req.err || \"Union failed.\"}}) }\n\t\t}\n\t\tGun.obj.map(gun.__.opt.peers, function(){ // only create server if peers and do it once by returning immediately.\n\t\t\treturn (tab.server.able = tab.server.able || tab.request.createServer(tab.server) || true);\n\t\t});\n\t\tgun.__.opt.wire.get = gun.__.opt.wire.get || tab.get;\n\t\tgun.__.opt.wire.put = gun.__.opt.wire.put || tab.put;\n\t\tgun.__.opt.wire.key = gun.__.opt.wire.key || tab.key;\n\n\t\tTab.request = tab.request;\n\t\tGun.Tab = Tab;\n\t});\n\n}.bind(this || module)({}));\n\n\n;(function(Tab){\n\tvar request = (function(){\n\t\tfunction r(base, body, cb, opt){ opt = opt || {};\n\t\t\tvar o = base.length? {base: base} : {};\n\t\t\to.base = opt.base || base;\n\t\t\to.body = opt.body || body;\n\t\t\to.headers = opt.headers;\n\t\t\to.url = opt.url;\n\t\t\tcb = cb || function(){};\n\t\t\tif(!o.base){ return }\n\t\t\tr.transport(o, cb);\n\t\t}\n\t\tr.createServer = function(fn){ r.createServer.s.push(fn) }\n\t\tr.createServer.ing = function(req, cb){\n\t\t\tvar i = r.createServer.s.length;\n\t\t\twhile(i--){ (r.createServer.s[i] || function(){})(req, cb) }\n\t\t}\n\t\tr.createServer.s = [];\n\t\tr.back = 2; r.backoff = 2; r.backmax = 2000;\n\t\tr.transport = function(opt, cb){\n\t\t\t//Gun.log(\"TRANSPORT:\", opt);\n\t\t\tif(r.ws(opt, cb)){ return }\n\t\t\tr.jsonp(opt, cb);\n\t\t}\n\n\t\tvar queues = r.queues = {};\n\n\t\tr.ws = function(opt, cb){\n\t\t\tvar ws, WS = r.WebSocket || window.WebSocket || window.mozWebSocket || window.webkitWebSocket;\n\t\t\tif(!WS){ return }\n\n\t\t\t// Queued offline updates.\n\t\t\tvar queue = queues[opt.base];\n\n\t\t\t// Create the queue if it doesn't exist.\n\t\t\tif (!queue) {\n\t\t\t\tqueue = queues[opt.base] = {};\n\t\t\t}\n\n\t\t\t// Try to de-duplicate queued messages.\n\t\t\tvar reqID = ((opt || {}).headers || {}).id || Gun.text.random(9);\n\n\t\t\tws = r.ws.peers[opt.base];\n\t\t\tif(ws && (ws.readyState <= ws.OPEN)){\n\t\t\t\tif(ws.readyState === ws.CONNECTING){\n\t\t\t\t\tqueue[reqID] = [opt, cb];\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tvar req = {};\n\t\t\t\tif(opt.headers){ req.headers = opt.headers }\n\t\t\t\tif(opt.body){ req.body = opt.body }\n\t\t\t\tif(opt.url){ req.url = opt.url }\n\t\t\t\treq.headers = req.headers || {};\n\t\t\t\tr.ws.cbs[req.headers['ws-rid'] = 'WS' + (+ new Date()) + '.' + Math.floor((Math.random()*65535)+1)] = function(err,res){\n\t\t\t\t\tif(res.body || res.end){ delete r.ws.cbs[req.headers['ws-rid']] }\n\t\t\t\t\tcb(err,res);\n\t\t\t\t}\n\n\t\t\t\tws.send(JSON.stringify(req),function(err){});\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif(ws === false){ return }\n\n\t\t\t// If we've made it this far, the socket isn't open.\n\t\t\tqueue[reqID] = [opt, cb];\n\n\t\t\ttry{ws = r.ws.peers[opt.base] = new WS(opt.base.replace('http','ws'));\n\t\t\t}catch(e){}\n\n\t\t\tws.onopen = function(o){\n\n\t\t\t\t// Send the queued messages.\n\t\t\t\tr.each(queue, function (deferred) {\n\t\t\t\t\tr.ws.apply(null, deferred);\n\t\t\t\t});\n\n\t\t\t\t// Clear the queue.\n\t\t\t\tqueue = queues[opt.base] = {};\n\n\t\t\t\t// Reset the reconnect backoff.\n\t\t\t\tr.back = 2;\n\t\t\t};\n\n\t\t\tws.onclose = function(c){\n\t\t\t\tif(!c){ return }\n\t\t\t\tif(ws && ws.close instanceof Function){ ws.close() }\n\t\t\t\tif(1006 === c.code){ // websockets cannot be used\n\t\t\t\t\t/*ws = r.ws.peers[opt.base] = false; // 1006 has mixed meanings, therefore we can no longer respect it.\n\t\t\t\t\tr.transport(opt, cb);\n\t\t\t\t\treturn;*/\n\t\t\t\t}\n\t\t\t\tws = r.ws.peers[opt.base] = null; // this will make the next request try to reconnect\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\tr.ws(opt, function(){}); // opt here is a race condition, is it not? Does this matter?\n\t\t\t\t}, (r.back *= r.backoff) > r.backmax ? (r.back = r.backmax) : r.back);\n\t\t\t};\n\t\t\tif(typeof window !== \"undefined\"){ window.onbeforeunload = ws.onclose; }\n\t\t\tws.onmessage = function(m){\n\t\t\t\tif(!m || !m.data){ return }\n\t\t\t\tvar res;\n\t\t\t\ttry{res = JSON.parse(m.data);\n\t\t\t\t}catch(e){ return }\n\t\t\t\tif(!res){ return }\n\t\t\t\tres.headers = res.headers || {};\n\t\t\t\tif(res.headers['ws-rid']){ return (r.ws.cbs[res.headers['ws-rid']]||function(){})(null, res) }\n\t\t\t\tif(res.body){ r.createServer.ing(res, function(res){ r(opt.base, null, null, res)}) } // emit extra events.\n\t\t\t};\n\t\t\tws.onerror = function(e){ console.log(e); };\n\t\t\treturn true;\n\t\t}\n\t\tr.ws.peers = {};\n\t\tr.ws.cbs = {};\n\t\tr.jsonp = function(opt, cb){\n\t\t\tif(typeof window === \"undefined\"){\n\t\t\t\treturn cb(\"JSONP is currently browser only.\");\n\t\t\t}\n\t\t\t//Gun.log(\"jsonp send\", opt);\n\t\t\tr.jsonp.ify(opt, function(url){\n\t\t\t\t//Gun.log(url);\n\t\t\t\tif(!url){ return }\n\t\t\t\tr.jsonp.send(url, function(reply){\n\t\t\t\t\t//Gun.log(\"jsonp reply\", reply);\n\t\t\t\t\tcb(null, reply);\n\t\t\t\t\tr.jsonp.poll(opt, reply);\n\t\t\t\t}, opt.jsonp);\n\t\t\t});\n\t\t}\n\t\tr.jsonp.send = function(url, cb, id){\n\t\t\tvar js = document.createElement('script');\n\t\t\tjs.src = url;\n\t\t\twindow[js.id = id] = function(res){\n\t\t\t\tcb(res);\n\t\t\t\tcb.id = js.id;\n\t\t\t\tjs.parentNode.removeChild(js);\n\t\t\t\twindow[cb.id] = null; // TODO: BUG: This needs to handle chunking!\n\t\t\t\ttry{delete window[cb.id];\n\t\t\t\t}catch(e){}\n\t\t\t}\n\t\t\tjs.async = true;\n\t\t\tdocument.getElementsByTagName('head')[0].appendChild(js);\n\t\t\treturn js;\n\t\t}\n\t\tr.jsonp.poll = function(opt, res){\n\t\t\tif(!opt || !opt.base || !res || !res.headers || !res.headers.poll){ return }\n\t\t\t(r.jsonp.poll.s = r.jsonp.poll.s || {})[opt.base] = r.jsonp.poll.s[opt.base] || setTimeout(function(){ // TODO: Need to optimize for Chrome's 6 req limit?\n\t\t\t\t//Gun.log(\"polling again\");\n\t\t\t\tvar o = {base: opt.base, headers: {pull: 1}};\n\t\t\t\tr.each(opt.headers, function(v,i){ o.headers[i] = v })\n\t\t\t\tr.jsonp(o, function(err, reply){\n\t\t\t\t\tdelete r.jsonp.poll.s[opt.base];\n\t\t\t\t\twhile(reply.body && reply.body.length && reply.body.shift){ // we're assuming an array rather than chunk encoding. :(\n\t\t\t\t\t\tvar res = reply.body.shift();\n\t\t\t\t\t\t//Gun.log(\"-- go go go\", res);\n\t\t\t\t\t\tif(res && res.body){ r.createServer.ing(res, function(){ r(opt.base, null, null, res) }) } // emit extra events.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, res.headers.poll);\n\t\t}\n\t\tr.jsonp.ify = function(opt, cb){\n\t\t\tvar uri = encodeURIComponent, q = '?';\n\t\t\tif(opt.url && opt.url.pathname){ q = opt.url.pathname + q; }\n\t\t\tq = opt.base + q;\n\t\t\tr.each((opt.url||{}).query, function(v, i){ q += uri(i) + '=' + uri(v) + '&' });\n\t\t\tif(opt.headers){ q += uri('`') + '=' + uri(JSON.stringify(opt.headers)) + '&' }\n\t\t\tif(r.jsonp.max < q.length){ return cb() }\n\t\t\tq += uri('jsonp') + '=' + uri(opt.jsonp = 'P'+Math.floor((Math.random()*65535)+1));\n\t\t\tif(opt.body){\n\t\t\t\tq += '&';\n\t\t\t\tvar w = opt.body, wls = function(w,l,s){\n\t\t\t\t\treturn uri('%') + '=' + uri(w+'-'+(l||w)+'/'+(s||w))  + '&' + uri('$') + '=';\n\t\t\t\t}\n\t\t\t\tif(typeof w != 'string'){\n\t\t\t\t\tw = JSON.stringify(w);\n\t\t\t\t\tq += uri('^') + '=' + uri('json') + '&';\n\t\t\t\t}\n\t\t\t\tw = uri(w);\n\t\t\t\tvar i = 0, l = w.length\n\t\t\t\t, s = r.jsonp.max - (q.length + wls(l.toString()).length);\n\t\t\t\tif(s < 0){ return cb() }\n\t\t\t\twhile(w){\n\t\t\t\t\tcb(q + wls(i, (i = i + s), l) + w.slice(0, i));\n\t\t\t\t\tw = w.slice(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcb(q);\n\t\t\t}\n\t\t}\n\t\tr.jsonp.max = 2000;\n\t\tr.each = function(obj, cb){\n\t\t\tif(!obj || !cb){ return }\n\t\t\tfor(var i in obj){\n\t\t\t\tif(obj.hasOwnProperty(i)){\n\t\t\t\t\tcb(obj[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}());\n\tif(typeof window !== \"undefined\"){ Gun.request = request }\n\tif(typeof module !== \"undefined\" && module.exports){ module.exports.request = request }\n}.bind(this || module)({}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gun/gun.js\n// module id = 1\n// module chunks = 0 1","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 2\n// module chunks = 0 1"],"sourceRoot":""}